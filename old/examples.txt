
// FILE ./cooperative-gestures.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Cooperative gestures</title>
    <meta property="og:description" content="Enable cooperative gestures with a specific language. See how it behaves in fullscreen mode." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<div id="map"></div>

<script>
    const map = new maplibregl.Map({
        container: 'map',
        style: 'https://demotiles.maplibre.org/style.json',
        center: [-74.5, 40],
        cooperativeGestures: true,
        locale: {
            'CooperativeGesturesHandler.WindowsHelpText': 'Utilice Ctrl + desplazamiento para hacer zoom en el mapa.',
            'CooperativeGesturesHandler.MacHelpText': 'Usa ⌘ + desplazamiento para hacer zoom en el mapa.',
            'CooperativeGesturesHandler.MobileHelpText': 'Usa dos dedos para mover el mapa.',
        },
        zoom: 4
    });
    map.addControl(new maplibregl.FullscreenControl());
</script>
</body>
</html>
```

// FILE ./locate-user.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Locate the user</title>
    <meta property="og:description" content="Geolocate the user and then track their current location on the map using the GeolocateControl." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<div id="map"></div>
<script>
    const map = new maplibregl.Map({
        container: 'map', // container id
        style:
            'https://api.maptiler.com/maps/streets/style.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL',
        center: [-96, 37.8], // starting position
        zoom: 3 // starting zoom
    });

    // Add geolocate control to the map.
    map.addControl(
        new maplibregl.GeolocateControl({
            positionOptions: {
                enableHighAccuracy: true
            },
            trackUserLocation: true
        })
    );
</script>
</body>
</html>
```

// FILE ./animate-images.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Animate a series of images</title>
    <meta property="og:description" content="Use a series of image sources to create an animation." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<div id="map"></div>
<script>
    const map = new maplibregl.Map({
        container: 'map',
        style:
            'https://api.maptiler.com/maps/streets/style.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL',
        maxZoom: 5.99,
        minZoom: 4,
        zoom: 5,
        center: [-75.789, 41.874]
    });

    const frameCount = 5;
    let currentImage = 0;

    function getPath() {
        return (
            `https://maplibre.org/maplibre-gl-js/docs/assets/radar${
                currentImage
            }.gif`
        );
    }

    map.on('load', () => {
        map.addSource('radar', {
            type: 'image',
            url: getPath(),
            coordinates: [
                [-80.425, 46.437],
                [-71.516, 46.437],
                [-71.516, 37.936],
                [-80.425, 37.936]
            ]
        });
        map.addLayer({
            id: 'radar-layer',
            'type': 'raster',
            'source': 'radar',
            'paint': {
                'raster-fade-duration': 0
            }
        });

        setInterval(() => {
            currentImage = (currentImage + 1) % frameCount;
            map.getSource('radar').updateImage({url: getPath()});
        }, 200);
    });
</script>
</body>
</html>
```

// FILE ./popup-on-hover.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Display a popup on hover</title>
    <meta property="og:description" content="When a user hovers over a custom marker, show a popup containing more information." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<style>
    .maplibregl-popup {
        max-width: 400px;
        font: 12px/20px 'Helvetica Neue', Arial, Helvetica, sans-serif;
    }
</style>
<div id="map"></div>
<script>
    const map = new maplibregl.Map({
        container: 'map',
        style: 'https://api.maptiler.com/maps/streets/style.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL',
        center: [-77.04, 38.907],
        zoom: 11.15
    });

    map.on('load', async () => {
        const image = await map.loadImage('https://maplibre.org/maplibre-gl-js/docs/assets/custom_marker.png');
        // Add an image to use as a custom marker
        map.addImage('custom-marker', image.data);

        map.addSource('places', {
            'type': 'geojson',
            'data': {
                'type': 'FeatureCollection',
                'features': [
                    {
                        'type': 'Feature',
                        'properties': {
                            'description':
                                '<strong>Make it Mount Pleasant</strong><p>Make it Mount Pleasant is a handmade and vintage market and afternoon of live entertainment and kids activities. 12:00-6:00 p.m.</p>'
                        },
                        'geometry': {
                            'type': 'Point',
                            'coordinates': [-77.038659, 38.931567]
                        }
                    },
                    {
                        'type': 'Feature',
                        'properties': {
                            'description':
                                '<strong>Mad Men Season Five Finale Watch Party</strong><p>Head to Lounge 201 (201 Massachusetts Avenue NE) Sunday for a Mad Men Season Five Finale Watch Party, complete with 60s costume contest, Mad Men trivia, and retro food and drink. 8:00-11:00 p.m. $10 general admission, $20 admission and two hour open bar.</p>'
                        },
                        'geometry': {
                            'type': 'Point',
                            'coordinates': [-77.003168, 38.894651]
                        }
                    },
                    {
                        'type': 'Feature',
                        'properties': {
                            'description':
                                '<strong>Big Backyard Beach Bash and Wine Fest</strong><p>EatBar (2761 Washington Boulevard Arlington VA) is throwing a Big Backyard Beach Bash and Wine Fest on Saturday, serving up conch fritters, fish tacos and crab sliders, and Red Apron hot dogs. 12:00-3:00 p.m. $25.</p>'
                        },
                        'geometry': {
                            'type': 'Point',
                            'coordinates': [-77.090372, 38.881189]
                        }
                    },
                    {
                        'type': 'Feature',
                        'properties': {
                            'description':
                                '<strong>Ballston Arts & Crafts Market</strong><p>The Ballston Arts & Crafts Market sets up shop next to the Ballston metro this Saturday for the first of five dates this summer. Nearly 35 artists and crafters will be on hand selling their wares. 10:00-4:00 p.m.</p>'
                        },
                        'geometry': {
                            'type': 'Point',
                            'coordinates': [-77.111561, 38.882342]
                        }
                    },
                    {
                        'type': 'Feature',
                        'properties': {
                            'description':
                                '<strong>Seersucker Bike Ride and Social</strong><p>Feeling dandy? Get fancy, grab your bike, and take part in this year\'s Seersucker Social bike ride from Dandies and Quaintrelles. After the ride enjoy a lawn party at Hillwood with jazz, cocktails, paper hat-making, and more. 11:00-7:00 p.m.</p>'
                        },
                        'geometry': {
                            'type': 'Point',
                            'coordinates': [-77.052477, 38.943951]
                        }
                    },
                    {
                        'type': 'Feature',
                        'properties': {
                            'description':
                                '<strong>Capital Pride Parade</strong><p>The annual Capital Pride Parade makes its way through Dupont this Saturday. 4:30 p.m. Free.</p>'
                        },
                        'geometry': {
                            'type': 'Point',
                            'coordinates': [-77.043444, 38.909664]
                        }
                    },
                    {
                        'type': 'Feature',
                        'properties': {
                            'description':
                                '<strong>Muhsinah</strong><p>Jazz-influenced hip hop artist Muhsinah plays the Black Cat (1811 14th Street NW) tonight with Exit Clov and Gods’illa. 9:00 p.m. $12.</p>'
                        },
                        'geometry': {
                            'type': 'Point',
                            'coordinates': [-77.031706, 38.914581]
                        }
                    },
                    {
                        'type': 'Feature',
                        'properties': {
                            'description':
                                '<strong>A Little Night Music</strong><p>The Arlington Players\' production of Stephen Sondheim\'s <em>A Little Night Music</em> comes to the Kogod Cradle at The Mead Center for American Theater (1101 6th Street SW) this weekend and next. 8:00 p.m.</p>'
                        },
                        'geometry': {
                            'type': 'Point',
                            'coordinates': [-77.020945, 38.878241]
                        }
                    },
                    {
                        'type': 'Feature',
                        'properties': {
                            'description':
                                '<strong>Truckeroo</strong><p>Truckeroo brings dozens of food trucks, live music, and games to half and M Street SE (across from Navy Yard Metro Station) today from 11:00 a.m. to 11:00 p.m.</p>'
                        },
                        'geometry': {
                            'type': 'Point',
                            'coordinates': [-77.007481, 38.876516]
                        }
                    }
                ]
            }
        });

        // Add a layer showing the places.
        map.addLayer({
            'id': 'places',
            'type': 'symbol',
            'source': 'places',
            'layout': {
                'icon-image': 'custom-marker',
                'icon-overlap': 'always'
            }
        });

        // Create a popup, but don't add it to the map yet.
        const popup = new maplibregl.Popup({
            closeButton: false,
            closeOnClick: false
        });

        // Make sure to detect marker change for overlapping markers
        // and use mousemove instead of mouseenter event
        let currentFeatureCoordinates = undefined;
        map.on('mousemove', 'places', (e) => {
            const featureCoordinates = e.features[0].geometry.coordinates.toString();
            if (currentFeatureCoordinates !== featureCoordinates) {
                currentFeatureCoordinates = featureCoordinates;

                // Change the cursor style as a UI indicator.
                map.getCanvas().style.cursor = 'pointer';

                const coordinates = e.features[0].geometry.coordinates.slice();
                const description = e.features[0].properties.description;

                // Ensure that if the map is zoomed out such that multiple
                // copies of the feature are visible, the popup appears
                // over the copy being pointed to.
                while (Math.abs(e.lngLat.lng - coordinates[0]) > 180) {
                    coordinates[0] += e.lngLat.lng > coordinates[0] ? 360 : -360;
                }

                // Populate the popup and set its coordinates
                // based on the feature found.
                popup.setLngLat(coordinates).setHTML(description).addTo(map);
            }
        });

        map.on('mouseleave', 'places', () => {
            currentFeatureCoordinates = undefined;
            map.getCanvas().style.cursor = '';
            popup.remove();
        });
    });
</script>
</body>
</html>
```

// FILE ./center-on-symbol.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Center the map on a clicked symbol</title>
    <meta property="og:description" content="Use events and flyTo to center the map on a symbol." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<div id="map"></div>
<script>
    const map = new maplibregl.Map({
        container: 'map',
        style:
            'https://api.maptiler.com/maps/streets/style.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL',
        center: [-90.96, -0.47],
        zoom: 7.5
    });

    map.on('load', async () => {
        // Add an image to use as a custom marker
        const image = await map.loadImage('https://maplibre.org/maplibre-gl-js/docs/assets/custom_marker.png');
        map.addImage('custom-marker', image.data);
        // Add a GeoJSON source with 3 points.
        map.addSource('points', {
            'type': 'geojson',
            'data': {
                'type': 'FeatureCollection',
                'features': [
                    {
                        'type': 'Feature',
                        'properties': {},
                        'geometry': {
                            'type': 'Point',
                            'coordinates': [
                                -91.395263671875,
                                -0.9145729757782163
                            ]
                        }
                    },
                    {
                        'type': 'Feature',
                        'properties': {},
                        'geometry': {
                            'type': 'Point',
                            'coordinates': [
                                -90.32958984375,
                                -0.6344474832838974
                            ]
                        }
                    },
                    {
                        'type': 'Feature',
                        'properties': {},
                        'geometry': {
                            'type': 'Point',
                            'coordinates': [
                                -91.34033203125,
                                0.01647949196029245
                            ]
                        }
                    }
                ]
            }
        });

        // Add a symbol layer
        map.addLayer({
            'id': 'symbols',
            'type': 'symbol',
            'source': 'points',
            'layout': {
                'icon-image': 'custom-marker'
            }
        });

        // Center the map on the coordinates of any clicked symbol from the 'symbols' layer.
        map.on('click', 'symbols', (e) => {
            map.flyTo({
                center: e.features[0].geometry.coordinates
            });
        });

        // Change the cursor to a pointer when the it enters a feature in the 'symbols' layer.
        map.on('mouseenter', 'symbols', () => {
            map.getCanvas().style.cursor = 'pointer';
        });

        // Change it back to a pointer when it leaves.
        map.on('mouseleave', 'symbols', () => {
            map.getCanvas().style.cursor = '';
        });
    });
</script>
</body>
</html>
```

// FILE ./hash-router.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Hash routing</title>
    <meta property="og:description" content="Keep the viewport state in the url with hash routing." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
        #urlHash {
            position: fixed;
            left: 0;
            top: 0;
            height: 30px;
            background-color: white;
            display: flex;
            align-items: center;
            border-radius: 10px;
            padding: 0 10px;
            margin: 10px;
            border: 1px solid #888;
        }
    </style>
</head>
<body>
<div id="map"></div>
<span id="urlHash"></span>
<script>
    const map = new maplibregl.Map({
        container: 'map',
        hash: true, // <- Enable hash routing
        style: 'https://demotiles.maplibre.org/style.json',
        center: [0, 0],
        zoom: 1,
        maplibreLogo: true
    });

    // Set an interval to update the url hash in a map overlay
    const urlHash = document.getElementById('urlHash');
    setInterval(() => {
        urlHash.textContent = `URL hash: ${window.location.hash}`;
    }, 100);

</script>
</body>
</html>
```

// FILE ./draw-a-radius.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Draw a Circle</title>
    <meta property="og:description" content="Draw a radius to approximate a location with Turf.js" />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<script src="https://cdn.jsdelivr.net/npm/@turf/turf@7/turf.min.js"></script>
<div id="map"></div>
<script>
    const radiusCenter = [2.3454, 48.8452];
    const map = new maplibregl.Map({
        container: 'map',
        zoom: 13,
        center: radiusCenter,
        style: {
            version: 8,
            sources: {
                osm: {
                    type: 'raster',
                    tiles: ['https://tile.openstreetmap.org/{z}/{x}/{y}.png'],
                    tileSize: 256,
                    attribution: '&copy; OpenStreetMap Contributors',
                    maxzoom: 19
                }
            },
            layers: [
                {
                    id: 'osm',
                    type: 'raster',
                    source: 'osm'
                }
            ]
        },
        maxZoom: 18,
        maxPitch: 85
    });

    map.on('load', () => {
        // Generate a polygon using turf.circle
        // See https://turfjs.org/docs/#circle
        const radius = 1; // kilometer
        const options = {
            steps: 64,
            units: 'kilometers'
        };
        const circle = turf.circle(radiusCenter, radius, options);

        // Add the circle as a GeoJSON source
        map.addSource('location-radius', {
            type: 'geojson',
            data: circle
        });

        // Add a fill layer with some transparency
        map.addLayer({
            id: 'location-radius',
            type: 'fill',
            source: 'location-radius',
            paint: {
                'fill-color': '#8CCFFF',
                'fill-opacity': 0.5
            }
        });

        // Add a line layer to draw the circle outline
        map.addLayer({
            id: 'location-radius-outline',
            type: 'line',
            source: 'location-radius',
            paint: {
                'line-color': '#0094ff',
                'line-width': 3
            }
        });
    });
</script>
</body>
</html>
```

// FILE ./change-building-color-based-on-zoom-level.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Change building color based on zoom level</title>
    <meta property="og:description" content="Use the interpolate expression to ease-in the building layer and smoothly fade from one color to the next." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<style>
    #zoom {
        display: block;
        position: absolute;
        top: 20px;
        left: 50%;
        transform: translate(-50%);
        width: 50%;
        height: 40px;
        padding: 10px;
        border: none;
        border-radius: 3px;
        font-size: 12px;
        text-align: center;
        color: #fff;
        background: #ee8a65;
    }
</style>
<div id="map"></div>
<button id="zoom">Zoom to buildings</button>
<script>
    const map = new maplibregl.Map({
        container: 'map',
        style:
            'https://api.maptiler.com/maps/basic/style.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL',
        center: [-90.73414, 14.55524],
        zoom: 13
    });

    map.on('load', () => {
        map.setPaintProperty('building', 'fill-color', [
            'interpolate',
            ['exponential', 0.5],
            ['zoom'],
            15,
            '#e2714b',
            22,
            '#eee695'
        ]);

        map.setPaintProperty('building', 'fill-opacity', [
            'interpolate',
            ['exponential', 0.5],
            ['zoom'],
            15,
            0,
            22,
            1
        ]);
    });

    document.getElementById('zoom').addEventListener('click', () => {
        map.zoomTo(19, {duration: 9000});
    });
</script>
</body>
</html>
```

// FILE ./mapbox-gl-rtl-text.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Add support for right-to-left scripts</title>
    <meta property="og:description" content="Use the mapbox-gl-rtl-text plugin to support right-to-left languages such as Arabic and Hebrew." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<div id="map"></div>

<script>
    maplibregl.setRTLTextPlugin(
        'https://unpkg.com/@mapbox/mapbox-gl-rtl-text@0.3.0/dist/mapbox-gl-rtl-text.js',
        true // Lazy load the plugin
    );

    const map = new maplibregl.Map({
        container: 'map',
        style:
            'https://api.maptiler.com/maps/streets/style.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL',
        center: [44.3763, 33.2788],
        zoom: 11
    });
</script>
</body>
</html>
```

// FILE ./video-on-a-map.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Add a video</title>
    <meta property="og:description" content="Display a video on top of a satellite raster baselayer." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<div id="map"></div>
<script>
    const videoStyle = {
        'version': 8,
        'sources': {
            'satellite': {
                'type': 'raster',
                'url':
                'https://api.maptiler.com/tiles/satellite/tiles.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL',
                'tileSize': 256
            },
            'video': {
                'type': 'video',
                'urls': [
                    'https://static-assets.mapbox.com/mapbox-gl-js/drone.mp4',
                    'https://static-assets.mapbox.com/mapbox-gl-js/drone.webm'
                ],
                'coordinates': [
                    [-122.51596391201019, 37.56238816766053],
                    [-122.51467645168304, 37.56410183312965],
                    [-122.51309394836426, 37.563391708549425],
                    [-122.51423120498657, 37.56161849366671]
                ]
            }
        },
        'layers': [
            {
                'id': 'background',
                'type': 'background',
                'paint': {
                    'background-color': 'rgb(4,7,14)'
                }
            },
            {
                'id': 'satellite',
                'type': 'raster',
                'source': 'satellite'
            },
            {
                'id': 'video',
                'type': 'raster',
                'source': 'video'
            }
        ]
    };

    const map = new maplibregl.Map({
        container: 'map',
        minZoom: 14,
        zoom: 17,
        center: [-122.514426, 37.562984],
        bearing: -96,
        style: videoStyle
    });

    let playingVideo = true;

    map.on('click', () => {
        playingVideo = !playingVideo;

        if (playingVideo) map.getSource('video').play();
        else map.getSource('video').pause();
    });
</script>
</body>
</html>
```

// FILE ./offset-vanishing-point-with-padding.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Offset the vanishing point using padding</title>
    <meta property="og:description" content="Offset the center or vanishing point of the map to reduce distortion when floating elements are displayed over the map." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<style>
    .rounded-rect {
        background: white;
        border-radius: 10px;
        box-shadow: 0 0 50px -25px black;
    }

    .flex-center {
        position: absolute;
        display: flex;
        justify-content: center;
        align-items: center;
    }

    .flex-center.left {
        left: 0px;
    }

    .flex-center.right {
        right: 0px;
    }

    .sidebar-content {
        position: absolute;
        width: 95%;
        height: 95%;
        font-family: Arial, Helvetica, sans-serif;
        font-size: 32px;
        color: gray;
    }

    .sidebar-toggle {
        position: absolute;
        width: 1.3em;
        height: 1.3em;
        overflow: visible;
        display: flex;
        justify-content: center;
        align-items: center;
    }

    .sidebar-toggle.left {
        right: -1.5em;
    }

    .sidebar-toggle.right {
        left: -1.5em;
    }

    .sidebar-toggle:hover {
        color: #0aa1cf;
        cursor: pointer;
    }

    .sidebar {
        transition: transform 1s;
        z-index: 1;
        width: 300px;
        height: 100%;
    }

    /*
  The sidebar styling has them "expanded" by default, we use CSS transforms to push them offscreen
  The toggleSidebar() function removes this class from the element in order to expand it.
*/
    .left.collapsed {
        transform: translateX(-295px);
    }

    .right.collapsed {
        transform: translateX(295px);
    }
</style>

<div id="map">
    <div id="left" class="sidebar flex-center left collapsed">
        <div class="sidebar-content rounded-rect flex-center">
            Left Sidebar
            <div
                class="sidebar-toggle rounded-rect left"
                onclick="toggleSidebar('left')"
            >
                &rarr;
            </div>
        </div>
    </div>
    <div id="right" class="sidebar flex-center right collapsed">
        <div class="sidebar-content rounded-rect flex-center">
            Right Sidebar
            <div
                class="sidebar-toggle rounded-rect right"
                onclick="toggleSidebar('right')"
            >
                &larr;
            </div>
        </div>
    </div>
</div>

<script>
    const center = [-77.01866, 38.888];
    const map = new maplibregl.Map({
        container: 'map',
        zoom: 12.5,
        center,
        pitch: 60,
        style:
            'https://api.maptiler.com/maps/streets/style.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL'
    });

    new maplibregl.Marker().setLngLat(center).addTo(map);

    function toggleSidebar(id) {
        const elem = document.getElementById(id);
        const classes = elem.className.split(' ');
        const collapsed = classes.indexOf('collapsed') !== -1;

        const padding = {};

        if (collapsed) {
            // Remove the 'collapsed' class from the class list of the element, this sets it back to the expanded state.
            classes.splice(classes.indexOf('collapsed'), 1);

            padding[id] = 300; // In px, matches the width of the sidebars set in .sidebar CSS class
            map.easeTo({
                padding,
                duration: 1000 // In ms, CSS transition duration property for the sidebar matches this value
            });
        } else {
            padding[id] = 0;
            // Add the 'collapsed' class to the class list of the element
            classes.push('collapsed');

            map.easeTo({
                padding,
                duration: 1000
            });
        }

        // Update the class list on the element
        elem.className = classes.join(' ');
    }

    map.on('load', () => {
        toggleSidebar('left');
    });
</script>
</body>
</html>
```

// FILE ./globe-custom-tiles.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Add a custom layer with tiles to a globe</title>
    <meta property="og:description" content="Use custom layer to display arbitrary tiles drawn with a custom WebGL shader on a globe." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
        #project {
            display: block;
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translate(-50%);
            width: 50%;
            height: 40px;
            padding: 10px;
            border: none;
            border-radius: 3px;
            font-size: 12px;
            text-align: center;
            color: #fff;
            background: #ee8a65;
        }
    </style>
</head>
<body>
<div id="map"></div>
<br />
<button id="project">Toggle projection</button>
<script>
    // This example demonstrates how to draw a custom layer consisting of
    // web mercator tiles with a custom shader.
    // Each drawn tile must be subdivided in order to be properly curved.
    // This example also handles poles.

    // Note that sometimes you can encounter single-pixel seams between tiles
    // of different zoom levels. To fix this, first draw all tiles using meshes
    // *without* borders and mark all drawn pixels in stencil, then draw
    // all tiles again, this time *with* borders and with stencil set to
    // fail all previously drawn pixels.
    // This approach ensures that no pixel that can be drawn inside some tile
    // will be instead covered by a mesh border (which is likely to contain invalid data).
    //
    // MapLibre uses this approach to draw raster tiles on globe. Borders on raster tiles
    // contain ugly stretched textures, we don't want that to cover pixels that could be
    // filled with a valid neighboring tile.

    const EXTENT = 8192;

    // Generate an arbitrary list of tiles to render
    function generateTileList(list, current) {
        list.push(current);
        const subdivide = current.z < 2 || (current.x === current.y && current.z < 3) || (current.x === 0 && current.y === 0 && current.z < 7);
        if (subdivide) {
            for (let x = 0; x < 2; x++) {
                for (let y = 0; y < 2; y++) {
                    generateTileList(list, {
                        x: current.x * 2 + x,
                        y: current.y * 2 + y,
                        z: current.z + 1,
                        wrap: current.wrap,
                    });
                }
            }
        }
    }
    const tilesToRender = [];
    for (let i = -1; i <= 1; i++) {
        generateTileList(tilesToRender, {x: 0, y: 0, z: 0, wrap: i});
    }

    const map = new maplibregl.Map({
        container: 'map',
        style: 'https://demotiles.maplibre.org/style.json',
        zoom: 2,
        center: [7.5, 58]
    });

    map.on('style.load', () => {
        map.setProjection({
            type: 'globe', // Set projection to globe
        });
    });

    document.getElementById('project').addEventListener('click', () => {
        // Toggle projection
        const currentProjection = map.getProjection();
        map.setProjection({
            type: currentProjection.type === 'globe' ? 'mercator' : 'globe',
        });
    });

    const uniforms = [
        'u_matrix',
        'u_projection_fallback_matrix',
        'u_projection_matrix',
        'u_projection_clipping_plane',
        'u_projection_transition',
        'u_projection_tile_mercator_coords',
    ];

    // create a custom style layer to implement the WebGL content
    const highlightLayer = {
        id: 'highlight',
        type: 'custom',
        shaderMap: new Map(),
        meshMap: new Map(),

        // Helper method for creating a shader based on current map projection - globe will automatically switch to mercator when some condition is fulfilled.
        getShader(gl, shaderDescription) {
            if (this.shaderMap.has(shaderDescription.variantName)) {
                return this.shaderMap.get(shaderDescription.variantName);
            }

            // Create GLSL source for vertex shader
            // Note: we pass in-tile position in range 0..EXTENT to projectTile.
            // By default the uniforms for custom layers are set up so that "projectTile" accepts mercator coordinates in range 0..1,
            // but in this example we set the uniforms ourselves to accept range 0..EXTENT just like regular MapLibre rendering.
            const vertexSource = `#version 300 es
            ${shaderDescription.vertexShaderPrelude}
            ${shaderDescription.define}
            
            in vec2 a_pos;
            out mediump vec2 v_pos;

            void main() {
                
                gl_Position = projectTile(a_pos);
                // We divide by EXTENT here just so we have something reasonable to display in the pixel shader.
                v_pos = a_pos / float(${EXTENT});
            }`;

            // create GLSL source for fragment shader
            const fragmentSource = `#version 300 es

            precision mediump float;

            in vec2 v_pos;

            out highp vec4 fragColor;
            void main() {
                float alpha = 0.5;
                fragColor = vec4(v_pos, 0.0, 1.0) * alpha;
            }`;

            // create a vertex shader
            const vertexShader = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(vertexShader, vertexSource);
            gl.compileShader(vertexShader);

            // create a fragment shader
            const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(fragmentShader, fragmentSource);
            gl.compileShader(fragmentShader);

            // link the two shaders into a WebGL program
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);

            this.aPos = gl.getAttribLocation(program, 'a_pos');

            const locations = {};

            for (const uniform of uniforms) {
                locations[uniform] = gl.getUniformLocation(program, uniform);
            }

            const result = {
                program,
                locations
            };

            this.shaderMap.set(shaderDescription.variantName, result);

            return result;
        },

        getTileMesh(gl, x, y, z, border) {
            // What granularity should we use? Query MapLibre's projection object's granularity settings.
            const granularity = map.style.projection.subdivisionGranularity.tile.getGranularityForZoomLevel(z);
            // Do we want north pole geometry?
            const north = y === 0;
            // Do we want south pole geometry?
            const south = y === (1 << z) - 1;
            const key = `${granularity}_${north}_${south}_${border}`;
            if (this.meshMap.has(key)) {
                return this.meshMap.get(key);
            }

            const meshBuffers = maplibregl.createTileMesh({
                granularity,
                generateBorders: border,
                extendToNorthPole: north,
                extendToSouthPole: south,
            }, '16bit');

            const vbo = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
            gl.bufferData(
                gl.ARRAY_BUFFER,
                meshBuffers.vertices,
                gl.STATIC_DRAW
            );
            gl.bindBuffer(gl.ARRAY_BUFFER, null);
            const ibo = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);
            gl.bufferData(
                gl.ELEMENT_ARRAY_BUFFER,
                meshBuffers.indices,
                gl.STATIC_DRAW
            );
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

            const mesh = {
                vbo,
                ibo,
                indexCount: meshBuffers.indices.byteLength / 2,
            };
            this.meshMap.set(key, mesh);
            return mesh;
        },

        onAdd (map, gl) {
            // Nothing to do.
        },

        // method fired on each animation frame
        render (gl, args) {
            const {program, locations} = this.getShader(gl, args.shaderData);

            const isBorderDemo = true;

            gl.disable(gl.DEPTH_TEST);
            gl.disable(gl.STENCIL_TEST);
            gl.disable(gl.CULL_FACE);
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

            gl.useProgram(program);

            const isGlobeProjection = args.shaderData.variantName === 'globe';

            for (const tile of tilesToRender) {
                if (isGlobeProjection && tile.wrap !== 0) {
                    continue; // No need to draw wrapped tiles on a globe.
                }

                const tileID = {
                    wrap: tile.wrap,
                    canonical: {
                        x: tile.x,
                        y: tile.y,
                        z: tile.z,
                    }
                };

                const projectionData = map.transform.getProjectionData({overscaledTileID: tileID, applyGlobeMatrix: true});

                gl.uniform4f(
                    locations['u_projection_clipping_plane'],
                    ...projectionData.clippingPlane // vec4
                );
                gl.uniform1f(
                    locations['u_projection_transition'],
                    projectionData.projectionTransition // float
                );

                // Set tile mercator extents accordingly
                const tileSize = 1.0 / (1 << tile.z);
                gl.uniform4f(
                    locations['u_projection_tile_mercator_coords'],
                    ...projectionData.tileMercatorCoords // vec4
                );

                // Shader variant name effectively tells us what projection code path should be used.
                gl.uniformMatrix4fv(
                    locations['u_projection_matrix'],
                    false,
                    projectionData.mainMatrix
                );
                gl.uniformMatrix4fv(
                    locations['u_projection_fallback_matrix'],
                    false,
                    projectionData.fallbackMatrix
                );
                const mesh = this.getTileMesh(gl, tile.x, tile.y, tile.z, false);
                gl.bindBuffer(gl.ARRAY_BUFFER, mesh.vbo);
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, mesh.ibo);
                gl.enableVertexAttribArray(this.aPos);
                gl.vertexAttribPointer(this.aPos, 2, gl.SHORT, false, 0, 0);
                gl.drawElements(gl.TRIANGLES, mesh.indexCount, gl.UNSIGNED_SHORT, 0);
            }
        }
    };

    // add the custom style layer to the map
    map.on('load', () => {
        map.addLayer(highlightLayer, 'countries-label');
    });
</script>
</body>
</html>
```

// FILE ./add-image-generated.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Add a generated icon to the map</title>
    <meta property="og:description" content="Add an icon to the map that was generated at runtime." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<div id="map"></div>

<script>
    const map = new maplibregl.Map({
        container: 'map',
        style:
            'https://api.maptiler.com/maps/streets/style.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL'
    });

    map.on('load', () => {
        const width = 64; // The image will be 64 pixels square
        const bytesPerPixel = 4; // Each pixel is represented by 4 bytes: red, green, blue, and alpha.
        const data = new Uint8Array(width * width * bytesPerPixel);

        for (let x = 0; x < width; x++) {
            for (let y = 0; y < width; y++) {
                const offset = (y * width + x) * bytesPerPixel;
                data[offset + 0] = (y / width) * 255; // red
                data[offset + 1] = (x / width) * 255; // green
                data[offset + 2] = 128; // blue
                data[offset + 3] = 255; // alpha
            }
        }

        map.addImage('gradient', {width, height: width, data});

        map.addSource('point', {
            'type': 'geojson',
            'data': {
                'type': 'FeatureCollection',
                'features': [
                    {
                        'type': 'Feature',
                        'geometry': {
                            'type': 'Point',
                            'coordinates': [0, 0]
                        }
                    }
                ]
            }
        });
        map.addLayer({
            'id': 'points',
            'type': 'symbol',
            'source': 'point',
            'layout': {
                'icon-image': 'gradient'
            }
        });
    });
</script>
</body>
</html>
```

// FILE ./animate-symbol-to-follow-mouse.html
```
<!DOCTYPE html>
<html lang="en">

<head>
    <title>Animate symbol to follow the mouse</title>
    <meta property="og:description" content="Animate symbol to follow the mouse." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body {
            margin: 0;
            padding: 0;
        }

        html,
        body,
        #map {
            height: 100%;
        }
    </style>
</head>

<body>
    <div id="map"></div>
    <script>
        const map = new maplibregl.Map({
            container: 'map',
            projection: {type: 'globe'},
            style:
                'https://api.maptiler.com/maps/streets/style.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL',
            center: [0, 0],
            zoom: 2
        });

        map.on('mousemove', (e) => {
            const lngLat = e.lngLat.wrap();
            const pointSource = map.getSource('point');

            if (pointSource && lngLat.lng && lngLat.lat) {
                pointSource.setData({
                    'type': 'Point',
                    'coordinates': [lngLat.lng, lngLat.lat]
                });
            }
        });
        map.addControl(new maplibregl.GlobeControl());

        map.on('load', () => {

            map.addSource('point', {
                'type': 'geojson',
                'data': {
                    'type': 'Point',
                    'coordinates': [0, 0]
                }
            });

            map.addLayer({
                'id': 'point',
                'source': 'point',
                'type': 'symbol',
                'layout': {
                    'icon-image': 'airport_15',
                    'icon-allow-overlap': true,
                    'icon-ignore-placement': true
                },
            });
        });
    </script>
</body>

</html>
```

// FILE ./variable-label-placement.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Variable label placement</title>
    <meta property="og:description" content="Use text-variable-anchor to allow high priority labels to shift position to stay on the map." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<div id="map"></div>

<script>
    const places = {
        'type': 'FeatureCollection',
        'features': [
            {
                'type': 'Feature',
                'properties': {
                    'description': 'Ford\'s Theater',
                    'icon': 'theatre'
                },
                'geometry': {
                    'type': 'Point',
                    'coordinates': [-77.038659, 38.931567]
                }
            },
            {
                'type': 'Feature',
                'properties': {
                    'description': 'The Gaslight',
                    'icon': 'theatre'
                },
                'geometry': {
                    'type': 'Point',
                    'coordinates': [-77.003168, 38.894651]
                }
            },
            {
                'type': 'Feature',
                'properties': {
                    'description': 'Horrible Harry\'s',
                    'icon': 'bar'
                },
                'geometry': {
                    'type': 'Point',
                    'coordinates': [-77.090372, 38.881189]
                }
            },
            {
                'type': 'Feature',
                'properties': {
                    'description': 'Bike Party',
                    'icon': 'bicycle'
                },
                'geometry': {
                    'type': 'Point',
                    'coordinates': [-77.052477, 38.943951]
                }
            },
            {
                'type': 'Feature',
                'properties': {
                    'description': 'Rockabilly Rockstars',
                    'icon': 'music'
                },
                'geometry': {
                    'type': 'Point',
                    'coordinates': [-77.031706, 38.914581]
                }
            },
            {
                'type': 'Feature',
                'properties': {
                    'description': 'District Drum Tribe',
                    'icon': 'music'
                },
                'geometry': {
                    'type': 'Point',
                    'coordinates': [-77.020945, 38.878241]
                }
            },
            {
                'type': 'Feature',
                'properties': {
                    'description': 'Motown Memories',
                    'icon': 'music'
                },
                'geometry': {
                    'type': 'Point',
                    'coordinates': [-77.007481, 38.876516]
                }
            }
        ]
    };

    const map = new maplibregl.Map({
        container: 'map',
        style: 'https://api.maptiler.com/maps/streets/style.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL',
        center: [-77.04, 38.907],
        zoom: 11.15
    });

    map.on('load', () => {
        // Add a GeoJSON source containing place coordinates and information.
        map.addSource('places', {
            'type': 'geojson',
            'data': places
        });

        map.addLayer({
            'id': 'poi-labels',
            'type': 'symbol',
            'source': 'places',
            'layout': {
                'text-field': ['get', 'description'],
                'text-variable-anchor': ['top', 'bottom', 'left', 'right'],
                'text-radial-offset': 0.5,
                'text-justify': 'auto',
                'icon-image': ['concat', ['get', 'icon'], '_15']
            }
        });

        map.rotateTo(180, {duration: 10000});
    });
</script>
</body>
</html>
```

// FILE ./camera-animation.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Customize camera animations</title>
    <meta property="og:description" content="Customize camera animations using AnimationOptions." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<style>
    .map-overlay {
        font: 12px/20px 'Helvetica Neue', Arial, Helvetica, sans-serif;
        position: absolute;
        width: 200px;
        top: 0;
        left: 0;
        padding: 10px;
    }

    .map-overlay .map-overlay-inner {
        background-color: #fff;
        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
        border-radius: 3px;
        padding: 10px;
        margin-bottom: 10px;
    }

    .map-overlay-inner fieldset {
        border: none;
        padding: 0;
        margin: 0 0 10px;
    }

    .map-overlay-inner fieldset:last-child {
        margin: 0;
    }

    .map-overlay-inner select {
        width: 100%;
    }

    .map-overlay-inner p {
        margin: 0;
    }

    .map-overlay-inner label {
        display: block;
        font-weight: bold;
    }

    .map-overlay-inner button {
        background-color: cornflowerblue;
        color: white;
        border-radius: 5px;
        display: inline-block;
        height: 20px;
        border: none;
        cursor: pointer;
    }

    .map-overlay-inner button:focus {
        outline: none;
    }

    .map-overlay-inner button:hover {
        background-color: blue;
        box-shadow: inset 0 0 0 3px rgba(0, 0, 0, 0.1);
        -webkit-transition: background-color 500ms linear;
        -ms-transition: background-color 500ms linear;
        transition: background-color 500ms linear;
    }

    .offset > label,
    .offset > input {
        display: inline;
    }

    #animateLabel {
        display: inline-block;
        min-width: 20px;
    }
</style>

<div id="map"></div>
<div class="map-overlay top">
    <div class="map-overlay-inner">
        <fieldset>
            <label for="easing">Select easing function</label>
            <select id="easing" name="easing">
                <option value="easeInCubic">Ease In Cubic</option>
                <option value="easeOutQuint">Ease Out Quint</option>
                <option value="easeInOutCirc">Ease In/Out Circ</option>
                <option value="easeOutBounce">Ease Out Bounce</option>
            </select>
        </fieldset>
        <fieldset>
            <label for="duration">Set animation duration</label>
            <p id="durationValue"></p>
            <input
                type="range"
                id="duration"
                name="duration"
                min="0"
                max="10000"
                step="500"
                value="1000"
            />
        </fieldset>
        <fieldset>
            <label>Animate camera motion</label>
            <label for="animate" id="animateLabel">Yes</label>
            <input type="checkbox" id="animate" name="animate" checked />
        </fieldset>
        <fieldset class="offset">
            <label for="offset-x">Offset-X</label>
            <input
                type="number"
                id="offset-x"
                name="offset-x"
                min="-200"
                max="200"
                step="50"
                value="0"
            />
        </fieldset>
        <fieldset class="offset">
            <label for="offset-y">Offset-Y</label>
            <input
                type="number"
                id="offset-y"
                name="offset-y"
                min="-200"
                max="200"
                step="50"
                value="0"
            />
            <p>Offsets can be negative</p>
        </fieldset>
        <button type="button" id="animateButton" name="test-animation">
            Test Animation
        </button>
    </div>
</div>

<script>
    // declare various easing functions.
    // easing functions mathematically describe
    // how fast a value changes during an animation.
    // each function takes a parameter t that represents
    // the progress of the animation.
    // t is in a range of 0 to 1 where 0 is the initial
    // state and 1 is the completed state.
    const easingFunctions = {
    // start slow and gradually increase speed
        easeInCubic (t) {
            return t * t * t;
        },
        // start fast with a long, slow wind-down
        easeOutQuint (t) {
            return 1 - Math.pow(1 - t, 5);
        },
        // slow start and finish with fast middle
        easeInOutCirc (t) {
            return t < 0.5 ?
                (1 - Math.sqrt(1 - Math.pow(2 * t, 2))) / 2 :
                (Math.sqrt(1 - Math.pow(-2 * t + 2, 2)) + 1) / 2;
        },
        // fast start with a "bounce" at the end
        easeOutBounce (t) {
            const n1 = 7.5625;
            const d1 = 2.75;

            if (t < 1 / d1) {
                return n1 * t * t;
            } else if (t < 2 / d1) {
                return n1 * (t -= 1.5 / d1) * t + 0.75;
            } else if (t < 2.5 / d1) {
                return n1 * (t -= 2.25 / d1) * t + 0.9375;
            } else {
                return n1 * (t -= 2.625 / d1) * t + 0.984375;
            }
        }
    };

    // set up some helpful UX on the form
    const durationValueSpan = document.getElementById('durationValue');
    const durationInput = document.getElementById('duration');
    durationValueSpan.innerHTML = `${durationInput.value / 1000} seconds`;
    durationInput.addEventListener('change', (e) => {
        durationValueSpan.innerHTML = `${e.target.value / 1000} seconds`;
    });

    const animateLabel = document.getElementById('animateLabel');
    const animateValue = document.getElementById('animate');
    animateValue.addEventListener('change', (e) => {
        animateLabel.innerHTML = e.target.checked ? 'Yes' : 'No';
    });

    const map = new maplibregl.Map({
        container: 'map',
        style: 'https://api.maptiler.com/maps/streets/style.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL',
        center: [-95, 40],
        zoom: 3
    });

    map.on('load', () => {
        // add a layer to display the map's center point
        map.addSource('center', {
            'type': 'geojson',
            'data': {
                'type': 'Point',
                'coordinates': [-94, 40]
            }
        });
        map.addLayer({
            'id': 'center',
            'type': 'symbol',
            'source': 'center',
            'layout': {
                'icon-image': 'marker_15',
                'text-field': 'Center: [-94, 40]',
                'text-font': ['Open Sans Semibold', 'Arial Unicode MS Bold'],
                'text-offset': [0, 0.6],
                'text-anchor': 'top'
            }
        });

        const animateButton = document.getElementById('animateButton');
        animateButton.addEventListener('click', () => {
            const easingInput = document.getElementById('easing');
            const easingFn =
            easingFunctions[
                easingInput.options[easingInput.selectedIndex].value
            ];
            const duration = parseInt(durationInput.value, 10);
            const animate = animateValue.checked;
            const offsetX = parseInt(
                document.getElementById('offset-x').value,
                10
            );
            const offsetY = parseInt(
                document.getElementById('offset-y').value,
                10
            );

            const animationOptions = {
                duration,
                easing: easingFn,
                offset: [offsetX, offsetY],
                animate,
                essential: true // animation will happen even if user has `prefers-reduced-motion` setting on
            };

            // Create a random location to fly to by offsetting the map's
            // initial center point by up to 10 degrees.
            const center = [
                -95 + (Math.random() - 0.5) * 20,
                40 + (Math.random() - 0.5) * 20
            ];

            // merge animationOptions with other flyTo options
            animationOptions.center = center;

            map.flyTo(animationOptions);
            // update 'center' source and layer to show our new map center
            // compare this center point to where the camera ends up when an offset is applied
            map.getSource('center').setData({
                'type': 'Point',
                'coordinates': center
            });
            map.setLayoutProperty(
                'center',
                'text-field',
                `Center: [${
                    center[0].toFixed(1)
                }, ${
                    center[1].toFixed(1)
                }]`
            );
        });
    });
</script>
</body>
</html>
```

// FILE ./simple-map.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Display a map</title>
    <meta property="og:description" content="Initialize a map in an HTML element with MapLibre GL JS." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<div id="map"></div>
<script>
    const map = new maplibregl.Map({
        container: 'map', // container id
        style: 'https://demotiles.maplibre.org/style.json', // style URL
        center: [0, 0], // starting position [lng, lat]
        zoom: 1, // starting zoom
        maplibreLogo: true
    });
</script>
</body>
</html>
```

// FILE ./wms.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Add a WMS source</title>
    <meta property="og:description" content="Add an external Web Map Service raster layer to the map using addSource's tiles option." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<div id="map"></div>
<script>
    const map = new maplibregl.Map({
        container: 'map',
        style: 'https://api.maptiler.com/maps/streets/style.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL',
        zoom: 8,
        center: [-74.5447, 40.6892]
    });

    map.on('load', () => {
        map.addSource('wms-test-source', {
            'type': 'raster',
            // use the tiles option to specify a WMS tile source URL
            // https://maplibre.org/maplibre-style-spec/sources/
            'tiles': [
                'https://img.nj.gov/imagerywms/Natural2015?bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&srs=EPSG:3857&transparent=true&width=256&height=256&layers=Natural2015'
            ],
            'tileSize': 256
        });
        map.addLayer(
            {
                'id': 'wms-test-layer',
                'type': 'raster',
                'source': 'wms-test-source',
                'paint': {}
            },
            'aeroway_fill'
        );
    });
</script>
</body>
</html>
```

// FILE ./globe-custom-simple.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Add a simple custom layer on a globe</title>
    <meta property="og:description" content="Use a custom layer to draw simple WebGL content on a globe." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
        #project {
            display: block;
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translate(-50%);
            width: 50%;
            height: 40px;
            padding: 10px;
            border: none;
            border-radius: 3px;
            font-size: 12px;
            text-align: center;
            color: #fff;
            background: #ee8a65;
        }
    </style>
</head>
<body>
<div id="map"></div>
<br />
<button id="project">Toggle projection</button>
<script>
    const map = new maplibregl.Map({
        container: 'map',
        style: 'https://demotiles.maplibre.org/style.json',
        zoom: 3,
        center: [7.5, 58],
        canvasContextAttributes: {antialias: true}
    });

    map.on('style.load', () => {
        map.setProjection({
            type: 'globe', // Set projection to globe
        });
    });

    document.getElementById('project').addEventListener('click', () => {
        // Toggle projection
        const currentProjection = map.getProjection();
        map.setProjection({
            type: currentProjection.type === 'globe' ? 'mercator' : 'globe',
        });
    });

    // create a custom style layer to implement the WebGL content
    const highlightLayer = {
        id: 'highlight',
        type: 'custom',
        shaderMap: new Map(),

        // Helper method for creating a shader based on current map projection - globe will automatically switch to mercator when some condition is fulfilled.
        getShader(gl, shaderDescription) {
            // Pick a shader based on the current projection, defined by `variantName`.
            if (this.shaderMap.has(shaderDescription.variantName)) {
                return this.shaderMap.get(shaderDescription.variantName);
            }

            // Create GLSL source for vertex shader
            //
            // Note that we need to use a complex function to project from the source mercator
            // coordinates to the globe. Internal shaders in MapLibre need to do this too.
            // This is done using the `projectTile` function.
            // In MapLibre, this function accepts vertex coordinates local to the current tile,
            // in range 0..EXTENT (8192), but for custom layers MapLibre supplies uniforms such that
            // the function accepts mercator coordinates of the whole world in range 0..1.
            // This is controlled by the `u_projection_tile_mercator_coords` uniform.
            //
            // The `projectTile` function can also handle mercator to globe transitions and can
            // handle the mercator projection - different code is supplied based on what projection is used,
            // and for this reason we use different shaders based on what shader projection variant is currently used.
            // See `variantName` usage earlier in this file.
            //
            // The code for the projection function and uniforms is also supplied by MapLibre
            // and must be injected into custom layer shaders in order to draw on a globe.
            // We simply use string interpolation for that here.
            //
            // See MapLibre source code for more details, especially src/shaders/_projection_globe.vertex.glsl
            const vertexSource = `#version 300 es
            // Inject MapLibre projection code
            ${shaderDescription.vertexShaderPrelude}
            ${shaderDescription.define}
            
            in vec2 a_pos;

            void main() {
                gl_Position = projectTile(a_pos);
            }`;

            // create GLSL source for fragment shader
            const fragmentSource = `#version 300 es

            out highp vec4 fragColor;
            void main() {
                fragColor = vec4(1.0, 0.0, 1.0, 0.75);
            }`;

            // create a vertex shader
            const vertexShader = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(vertexShader, vertexSource);
            gl.compileShader(vertexShader);

            // create a fragment shader
            const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(fragmentShader, fragmentSource);
            gl.compileShader(fragmentShader);

            // link the two shaders into a WebGL program
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);

            this.aPos = gl.getAttribLocation(program, 'a_pos');

            this.shaderMap.set(shaderDescription.variantName, program);

            return program;
        },

        // method called when the layer is added to the map
        // Search for StyleImageInterface in https://maplibre.org/maplibre-gl-js/docs/API/
        onAdd (map, gl) {
            // define vertices of the triangle to be rendered in the custom style layer
            const helsinki = maplibregl.MercatorCoordinate.fromLngLat({
                lng: 25.004,
                lat: 60.239
            });
            const berlin = maplibregl.MercatorCoordinate.fromLngLat({
                lng: 13.403,
                lat: 52.562
            });
            const kyiv = maplibregl.MercatorCoordinate.fromLngLat({
                lng: 30.498,
                lat: 50.541
            });

            // create and initialize a WebGLBuffer to store vertex and color data
            this.buffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
            gl.bufferData(
                gl.ARRAY_BUFFER,
                new Float32Array([
                    helsinki.x,
                    helsinki.y,
                    kyiv.x,
                    kyiv.y,
                    berlin.x,
                    berlin.y,
                ]),
                gl.STATIC_DRAW
            );

            // Explanation of horizon clipping in MapLibre globe projection:
            //
            // When zooming in, the triangle will eventually start doing what at first glance
            // appears to be clipping the underlying map.
            //
            // Instead it is being clipped by the "horizon" plane, which the globe uses to
            // clip any geometry behind horizon (regular face culling isn't enough).
            // The horizon plane is not necessarily aligned with the near/far planes.
            // The clipping is done by assigning a custom value to `gl_Position.z` in the `projectTile`
            // MapLibre uses a constant z value per layer, so `gl_Position.z` can be anything,
            // since it later gets overwritten by `glDepthRange`.
            //
            // At high zooms, the triangle's three vertices can end up beyond the horizon plane,
            // resulting in the triangle getting clipped.
            //
            // This can be fixed by subdividing the triangle's geometry.
            // This is in general advisable to do, since without subdivision
            // geometry would not project to a curved shape under globe projection.
            // MapLibre also internally subdivides all geometry when globe projection is used.
        },

        // method fired on each animation frame
        render (gl, args) {
            const program = this.getShader(gl, args.shaderData);
            gl.useProgram(program);
            gl.uniformMatrix4fv(
                gl.getUniformLocation(program, 'u_projection_fallback_matrix'),
                false,
                args.defaultProjectionData.fallbackMatrix // convert mat4 from gl-matrix to a plain array
            );
            gl.uniformMatrix4fv(
                gl.getUniformLocation(program, 'u_projection_matrix'),
                false,
                args.defaultProjectionData.mainMatrix // convert mat4 from gl-matrix to a plain array
            );
            gl.uniform4f(
                gl.getUniformLocation(program, 'u_projection_tile_mercator_coords'),
                ...args.defaultProjectionData.tileMercatorCoords
            );
            gl.uniform4f(
                gl.getUniformLocation(program, 'u_projection_clipping_plane'),
                ...args.defaultProjectionData.clippingPlane
            );
            gl.uniform1f(
                gl.getUniformLocation(program, 'u_projection_transition'),
                args.defaultProjectionData.projectionTransition
            );

            gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
            gl.enableVertexAttribArray(this.aPos);
            gl.vertexAttribPointer(this.aPos, 2, gl.FLOAT, false, 0, 0);
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 3);
        }
    };

    // add the custom style layer to the map
    map.on('load', () => {
        map.addLayer(highlightLayer, 'crimea-fill');
    });
</script>
</body>
</html>
```

// FILE ./toggle-interaction-handlers.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Toggle interactions</title>
    <meta property="og:description" content="Enable or disable UI handlers on a map." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<style>
    .listing-group {
        font: 12px/20px 'Helvetica Neue', Arial, Helvetica, sans-serif;
        font-weight: 600;
        position: absolute;
        top: 10px;
        right: 10px;
        z-index: 1;
        border-radius: 3px;
        max-width: 20%;
        color: #fff;
    }

    .listing-group input[type='checkbox']:first-child + label {
        border-radius: 3px 3px 0 0;
    }

    .listing-group label:last-child {
        border-radius: 0 0 3px 3px;
        border: none;
    }

    .listing-group input[type='checkbox'] {
        display: none;
    }

    .listing-group input[type='checkbox'] + label {
        background-color: #3386c0;
        display: block;
        cursor: pointer;
        padding: 10px;
        border-bottom: 1px solid rgba(0, 0, 0, 0.25);
    }

    .listing-group input[type='checkbox'] + label {
        background-color: #3386c0;
        text-transform: capitalize;
    }

    .listing-group input[type='checkbox'] + label:hover,
    .listing-group input[type='checkbox']:checked + label {
        background-color: #4ea0da;
    }

    .listing-group input[type='checkbox']:checked + label:before {
        content: '✔';
        margin-right: 5px;
    }
</style>
<div id="map"></div>
<nav id="listing-group" class="listing-group">
    <input type="checkbox" id="scrollZoom" checked="checked" />
    <label for="scrollZoom">Scroll zoom</label>
    <input type="checkbox" id="boxZoom" checked="checked" />
    <label for="boxZoom">Box zoom</label>
    <input type="checkbox" id="dragRotate" checked="checked" />
    <label for="dragRotate">Drag rotate</label>
    <input type="checkbox" id="dragPan" checked="checked" />
    <label for="dragPan">Drag pan</label>
    <input type="checkbox" id="keyboard" checked="checked" />
    <label for="keyboard">Keyboard</label>
    <input type="checkbox" id="doubleClickZoom" checked="checked" />
    <label for="doubleClickZoom">Double click zoom</label>
    <input type="checkbox" id="touchZoomRotate" checked="checked" />
    <label for="touchZoomRotate">Touch zoom rotate</label>
</nav>

<script>
    const map = new maplibregl.Map({
        container: 'map',
        style:
            'https://api.maptiler.com/maps/streets/style.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL',
        center: [-77.04, 38.907],
        zoom: 11.15
    });

    document
        .getElementById('listing-group')
        .addEventListener('change', (e) => {
            const handler = e.target.id;
            if (e.target.checked) {
                map[handler].enable();
            } else {
                map[handler].disable();
            }
        });
</script>
</body>
</html>
```

// FILE ./interactive-false.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Display a non-interactive map</title>
    <meta property="og:description" content="Disable interactivity to create a static map." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<div id="map"></div>
<script>
    const map = new maplibregl.Map({
        container: 'map',
        style:
            'https://api.maptiler.com/maps/streets/style.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL',
        center: [-74.5, 40],
        zoom: 9,
        // causes pan & zoom handlers not to be applied, similar to
        // .dragging.disable() and other handler .disable() functions in Leaflet.
        interactive: false
    });
</script>
</body>
</html>
```

// FILE ./fill-pattern.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Add a pattern to a polygon</title>
    <meta property="og:description" content="Use fill-pattern to draw a polygon from a repeating image pattern." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<div id="map"></div>

<script>
    const map = new maplibregl.Map({
        container: 'map',
        style:
            'https://api.maptiler.com/maps/streets/style.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL',
        zoom: 1
    });

    map.on('load', async () => {
        // Add GeoJSON data
        map.addSource('source', {
            'type': 'geojson',
            'data': {
                'type': 'Feature',
                'properties': {},
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': [
                        [
                            [-30, -25],
                            [-30, 35],
                            [30, 35],
                            [30, -25],
                            [-30, -25]
                        ]
                    ]
                }
            }
        });

        // Load an image to use as the pattern
        const image = await map.loadImage('https://upload.wikimedia.org/wikipedia/commons/thumb/6/60/Cat_silhouette.svg/64px-Cat_silhouette.svg.png');
        // Declare the image
        map.addImage('pattern', image.data);

        // Use it
        map.addLayer({
            'id': 'pattern-layer',
            'type': 'fill',
            'source': 'source',
            'paint': {
                'fill-pattern': 'pattern'
            }
        });
    });
</script>
</body>
</html>
```

// FILE ./heatmap-globe-terrain.html
```
<!DOCTYPE html>
<html lang="en">

<head>
    <title>Create a Heatmap layer on a globe with terrain elevation</title>
    <meta property="og:description" content="Create a Heatmap layer on a globe with terrain elevation." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body {
            margin: 0;
            padding: 0;
        }

        html,
        body,
        #map {
            height: 100%;
        }
    </style>
</head>

<body>
    <div id="map"></div>
    <script>



        const map = new maplibregl.Map({
            container: 'map',
            maxPitch: 95,
            center: [-120, 37.422],
            zoom: 7.25,
            bearing: 57,
            pitch: 71,
            hash: true
        });

        map.setStyle('https://tiles.openfreemap.org/styles/liberty', {
            transformStyle: (previousStyle, nextStyle) => {
                nextStyle.projection = { type: 'globe' };
                nextStyle.sources = {
                    ...nextStyle.sources, terrainSource: {
                        type: 'raster-dem',
                        url: 'https://api.maptiler.com/tiles/terrain-rgb-v2/tiles.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL',
                        tileSize: 256
                    },
                    hillshadeSource: {
                        type: 'raster-dem',
                        url: 'https://api.maptiler.com/tiles/terrain-rgb-v2/tiles.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL',
                        tileSize: 256
                    }
                }
                nextStyle.terrain = {
                    source: 'terrainSource',
                    exaggeration: 1
                }

                nextStyle.sky = {
                    'atmosphere-blend': [
                        'interpolate',
                        ['linear'],
                        ['zoom'],
                        0, 1,
                        2, 0
                    ],
                }

                nextStyle.layers.push({
                    id: 'hills',
                    type: 'hillshade',
                    source: 'hillshadeSource',
                    layout: { visibility: 'visible' },
                    paint: { 'hillshade-shadow-color': '#473B24' }
                })

                return nextStyle
            }
        })

        map.addControl(
            new maplibregl.NavigationControl({
                visualizePitch: true,
                showZoom: true,
                showCompass: true
            })
        );


        map.addControl(
            new maplibregl.GlobeControl()
        );

        map.addControl(
            new maplibregl.TerrainControl({
                source: 'terrainSource',
                exaggeration: 1
            })
        );

        map.on('load', () => {
            // Add a geojson point source.
            // Heatmap layers also work with a vector tile source.
            map.addSource('earthquakes', {
                'type': 'geojson',
                'data':
                    'https://maplibre.org/maplibre-gl-js/docs/assets/earthquakes.geojson'
            });

            map.addLayer(
                {
                    'id': 'earthquakes-heat',
                    'type': 'heatmap',
                    'source': 'earthquakes',
                    'maxzoom': 9,
                    'paint': {
                        // Increase the heatmap weight based on frequency and property magnitude
                        'heatmap-weight': [
                            'interpolate',
                            ['linear'],
                            ['get', 'mag'],
                            0,
                            0,
                            6,
                            1
                        ],
                        // Increase the heatmap color weight weight by zoom level
                        // heatmap-intensity is a multiplier on top of heatmap-weight
                        'heatmap-intensity': [
                            'interpolate',
                            ['linear'],
                            ['zoom'],
                            0,
                            1,
                            9,
                            3
                        ],
                        // Color ramp for heatmap.  Domain is 0 (low) to 1 (high).
                        // Begin color ramp at 0-stop with a 0-transparency color
                        // to create a blur-like effect.
                        'heatmap-color': [
                            'interpolate',
                            ['linear'],
                            ['heatmap-density'],
                            0,
                            'rgba(33,102,172,0)',
                            0.2,
                            'rgb(103,169,207)',
                            0.4,
                            'rgb(209,229,240)',
                            0.6,
                            'rgb(253,219,199)',
                            0.8,
                            'rgb(239,138,98)',
                            1,
                            'rgb(178,24,43)'
                        ],
                        // Adjust the heatmap radius by zoom level
                        'heatmap-radius': [
                            'interpolate',
                            ['linear'],
                            ['zoom'],
                            0,
                            2,
                            9,
                            20
                        ],
                        // Transition from heatmap to circle layer by zoom level
                        'heatmap-opacity': [
                            'interpolate',
                            ['linear'],
                            ['zoom'],
                            7,
                            1,
                            9,
                            0
                        ]
                    }
                }
            );


            map.addLayer(
                {
                    'id': 'earthquakes-point',
                    'type': 'circle',
                    'source': 'earthquakes',
                    'minzoom': 7,
                    'paint': {
                        // Size circle radius by earthquake magnitude and zoom level
                        'circle-radius': [
                            'interpolate',
                            ['linear'],
                            ['zoom'],
                            7,
                            ['interpolate', ['linear'], ['get', 'mag'], 1, 1, 6, 4],
                            16,
                            ['interpolate', ['linear'], ['get', 'mag'], 1, 5, 6, 50]
                        ],
                        'circle-color': [
                            'interpolate',
                            ['linear'],
                            ['get', 'mag'],
                            1,
                            'rgba(33,102,172,0)',
                            2,
                            'rgb(103,169,207)',
                            3,
                            'rgb(209,229,240)',
                            4,
                            'rgb(253,219,199)',
                            5,
                            'rgb(239,138,98)',
                            6,
                            'rgb(178,24,43)'
                        ],
                        'circle-stroke-color': 'white',
                        'circle-stroke-width': 1,
                        // Transition from heatmap to circle layer by zoom level
                        'circle-opacity': [
                            'interpolate',
                            ['linear'],
                            ['zoom'],
                            7,
                            0,
                            8,
                            1
                        ]
                    }
                }
            );
        });
    </script>
</body>

</html>
```

// FILE ./filter-symbols-using-global-state.html
```
<!DOCTYPE html>
<html lang='en'>
<head>
    <title>Filter layer symbols using global state</title>
    <meta property="og:description" content="Filter a layer symbols based on user input using setGlobalStateProperty()." />
    <meta charset='utf-8'>
    <meta name='viewport' content='width=device-width, initial-scale=1'>
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body {
            margin: 0;
            padding: 0;
        }

        html,
        body,
        #map {
            height: 100%;
        }

        fieldset {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: white;
            padding: 10px;
        }
    </style>
</head>

<body>
    <div id='map'></div>
    <fieldset>
        Filter by type
        <select name="type">
            <option value="" selected>All</option>
            <option value="lift">Aerial lift</option>
            <option value="railway">Cable railway</option>
        </select>
    </fieldset>
</body>

<script>
    const map = new maplibregl.Map({
        container: 'map',
        style: 'https://demotiles.maplibre.org/style.json',
        center: [9.0679, 45.8822],
        zoom: 9
    });

    map.on('load', () => {
        map.addSource('railways_and_lifts', {
            type: 'geojson',
            data: 'https://maplibre.org/maplibre-gl-js/docs/assets/funicolares-and-funivias-como.json'
        });

        map.addLayer({
            id: 'railways_and_lifts_labels',
            type: 'symbol',
            source: 'railways_and_lifts',
            layout: {
                'text-field': '{name}',
                'text-font': ['Open Sans Semibold'],
                'text-offset': [0, 1],
                'text-anchor': 'top'
            },
            paint: {
                'text-color': '#000000',
                'text-halo-color': '#ffffff',
                'text-halo-width': 2
            },
            filter: [
                'case',
                ['==', ['to-string', ['global-state', 'type']], ''],
                true,
                ['==', ['get', 'type'], ['global-state', 'type']]
            ]
        });
        map.addLayer({
            type: 'circle',
            id: 'railways_and_lifts_points',
            source: 'railways_and_lifts',
            paint: {
                'circle-radius': 5,
                'circle-color': '#000000',
            },
            filter: [
                'case',
                ['==', ['to-string', ['global-state', 'type']], ''],
                true,
                ['==', ['get', 'type'], ['global-state', 'type']]
            ]
        });

        const select = document.querySelector('select[name="type"]');
        map.setGlobalStateProperty('type', select.value);

        select.addEventListener('change', (e) => {
            const value = e.target.value;
            map.setGlobalStateProperty('type', value);
        });
    });
</script>

</html>
```

// FILE ./check-for-support.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Check if WebGL is supported</title>
    <meta property="og:description" content="Check for WebGL browser support." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<div id="map"></div>

<script>
    function isWebglSupported() {
        if (window.WebGLRenderingContext) {
            const canvas = document.createElement('canvas');
            try {
                // Note that { failIfMajorPerformanceCaveat: true } can be passed as a second argument
                // to canvas.getContext(), causing the check to fail if hardware rendering is not available. See
                // https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/getContext
                // for more details.
                const context = canvas.getContext('webgl2') || canvas.getContext('webgl');
                if (context && typeof context.getParameter == 'function') {
                    return true;
                }
            } catch (e) {
                // WebGL is supported, but disabled
            }
            return false;
        }
        // WebGL not supported
        return false;
    }
    if (!isWebglSupported()) {
        alert('Your browser does not support WebGL');
    } else {
        const map = new maplibregl.Map({
            container: 'map',
            style:
            'https://api.maptiler.com/maps/streets/style.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL',
            center: [-74.5, 40],
            zoom: 9
        });
    }
</script>
</body>
</html>
```

// FILE ./cluster-html.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Display HTML clusters with custom properties</title>
    <meta property="og:description" content="Extend clustering with HTML markers and custom property expressions. " />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<div id="map"></div>

<script>
    const map = new maplibregl.Map({
        container: 'map',
        zoom: 0.3,
        center: [0, 20],
        style:
            'https://api.maptiler.com/maps/streets/style.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL'
    });

    map.addControl(new maplibregl.NavigationControl());

    // filters for classifying earthquakes into five categories based on magnitude
    const mag1 = ['<', ['get', 'mag'], 2];
    const mag2 = ['all', ['>=', ['get', 'mag'], 2], ['<', ['get', 'mag'], 3]];
    const mag3 = ['all', ['>=', ['get', 'mag'], 3], ['<', ['get', 'mag'], 4]];
    const mag4 = ['all', ['>=', ['get', 'mag'], 4], ['<', ['get', 'mag'], 5]];
    const mag5 = ['>=', ['get', 'mag'], 5];

    // colors to use for the categories
    const colors = ['#fed976', '#feb24c', '#fd8d3c', '#fc4e2a', '#e31a1c'];

    map.on('load', () => {
        // add a clustered GeoJSON source for a sample set of earthquakes
        map.addSource('earthquakes', {
            'type': 'geojson',
            'data':
                'https://maplibre.org/maplibre-gl-js/docs/assets/earthquakes.geojson',
            'cluster': true,
            'clusterRadius': 80,
            'clusterProperties': {
                // keep separate counts for each magnitude category in a cluster
                'mag1': ['+', ['case', mag1, 1, 0]],
                'mag2': ['+', ['case', mag2, 1, 0]],
                'mag3': ['+', ['case', mag3, 1, 0]],
                'mag4': ['+', ['case', mag4, 1, 0]],
                'mag5': ['+', ['case', mag5, 1, 0]]
            }
        });
        // circle and symbol layers for rendering individual earthquakes (unclustered points)
        map.addLayer({
            'id': 'earthquake_circle',
            'type': 'circle',
            'source': 'earthquakes',
            'filter': ['!=', 'cluster', true],
            'paint': {
                'circle-color': [
                    'case',
                    mag1,
                    colors[0],
                    mag2,
                    colors[1],
                    mag3,
                    colors[2],
                    mag4,
                    colors[3],
                    colors[4]
                ],
                'circle-opacity': 0.6,
                'circle-radius': 12
            }
        });
        map.addLayer({
            'id': 'earthquake_label',
            'type': 'symbol',
            'source': 'earthquakes',
            'filter': ['!=', 'cluster', true],
            'layout': {
                'text-field': [
                    'number-format',
                    ['get', 'mag'],
                    {'min-fraction-digits': 1, 'max-fraction-digits': 1}
                ],
                'text-font': ['Open Sans Semibold', 'Arial Unicode MS Bold'],
                'text-size': 10
            },
            'paint': {
                'text-color': [
                    'case',
                    ['<', ['get', 'mag'], 3],
                    'black',
                    'white'
                ]
            }
        });

        // objects for caching and keeping track of HTML marker objects (for performance)
        const markers = {};
        let markersOnScreen = {};

        function updateMarkers() {
            const newMarkers = {};
            const features = map.querySourceFeatures('earthquakes');

            // for every cluster on the screen, create an HTML marker for it (if we didn't yet),
            // and add it to the map if it's not there already
            for (let i = 0; i < features.length; i++) {
                const coords = features[i].geometry.coordinates;
                const props = features[i].properties;
                if (!props.cluster) continue;
                const id = props.cluster_id;

                let marker = markers[id];
                if (!marker) {
                    const el = createDonutChart(props);
                    marker = markers[id] = new maplibregl.Marker({
                        element: el
                    }).setLngLat(coords);
                }
                newMarkers[id] = marker;

                if (!markersOnScreen[id]) marker.addTo(map);
            }
            // for every marker we've added previously, remove those that are no longer visible
            for (id in markersOnScreen) {
                if (!newMarkers[id]) markersOnScreen[id].remove();
            }
            markersOnScreen = newMarkers;
        }

        // after the GeoJSON data is loaded, update markers on the screen and do so on every map move/moveend
        map.on('data', (e) => {
            if (e.sourceId !== 'earthquakes' || !e.isSourceLoaded) return;

            map.on('move', updateMarkers);
            map.on('moveend', updateMarkers);
            updateMarkers();
        });
    });

    // code for creating an SVG donut chart from feature properties
    function createDonutChart(props) {
        const offsets = [];
        const counts = [
            props.mag1,
            props.mag2,
            props.mag3,
            props.mag4,
            props.mag5
        ];
        let total = 0;
        for (let i = 0; i < counts.length; i++) {
            offsets.push(total);
            total += counts[i];
        }
        const fontSize =
        total >= 1000 ? 22 : total >= 100 ? 20 : total >= 10 ? 18 : 16;
        const r = total >= 1000 ? 50 : total >= 100 ? 32 : total >= 10 ? 24 : 18;
        const r0 = Math.round(r * 0.6);
        const w = r * 2;

        let html =
            `<div><svg width="${
                w
            }" height="${
                w
            }" viewbox="0 0 ${
                w
            } ${
                w
            }" text-anchor="middle" style="font: ${
                fontSize
            }px sans-serif; display: block">`;

        for (i = 0; i < counts.length; i++) {
            html += donutSegment(
                offsets[i] / total,
                (offsets[i] + counts[i]) / total,
                r,
                r0,
                colors[i]
            );
        }
        html +=
            `<circle cx="${
                r
            }" cy="${
                r
            }" r="${
                r0
            }" fill="white" /><text dominant-baseline="central" transform="translate(${
                r
            }, ${
                r
            })">${
                total.toLocaleString()
            }</text></svg></div>`;

        const el = document.createElement('div');
        el.innerHTML = html;
        return el.firstChild;
    }

    function donutSegment(start, end, r, r0, color) {
        if (end - start === 1) end -= 0.00001;
        const a0 = 2 * Math.PI * (start - 0.25);
        const a1 = 2 * Math.PI * (end - 0.25);
        const x0 = Math.cos(a0),
            y0 = Math.sin(a0);
        const x1 = Math.cos(a1),
            y1 = Math.sin(a1);
        const largeArc = end - start > 0.5 ? 1 : 0;

        return [
            '<path d="M',
            r + r0 * x0,
            r + r0 * y0,
            'L',
            r + r * x0,
            r + r * y0,
            'A',
            r,
            r,
            0,
            largeArc,
            1,
            r + r * x1,
            r + r * y1,
            'L',
            r + r0 * x1,
            r + r0 * y1,
            'A',
            r0,
            r0,
            0,
            largeArc,
            0,
            r + r0 * x0,
            r + r0 * y0,
            `" fill="${color}" />`
        ].join(' ');
    }
</script>
</body>
</html>
```

// FILE ./data-driven-lines.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Style lines with a data-driven property</title>
    <meta property="og:description" content="Create a visualization with a data expression for line-color." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<div id="map"></div>
<script>
    const map = new maplibregl.Map({
        container: 'map',
        style: 'https://api.maptiler.com/maps/streets/style.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL',
        center: [-122.48383155304096, 37.82882682974591],
        zoom: 16
    });

    map.on('load', () => {
        map.addSource('lines', {
            'type': 'geojson',
            'data': {
                'type': 'FeatureCollection',
                'features': [
                    {
                        'type': 'Feature',
                        'properties': {
                            'color': '#F7455D' // red
                        },
                        'geometry': {
                            'type': 'LineString',
                            'coordinates': [
                                [-122.4833858013153, 37.829607404976734],
                                [-122.4830961227417, 37.82932776098012],
                                [-122.4830746650696, 37.82932776098012],
                                [-122.48218417167662, 37.82889558180985],
                                [-122.48218417167662, 37.82890193740421],
                                [-122.48221099376678, 37.82868372835086],
                                [-122.4822163581848, 37.82868372835086],
                                [-122.48205006122589, 37.82801003030873]
                            ]
                        }
                    },
                    {
                        'type': 'Feature',
                        'properties': {
                            'color': '#33C9EB' // blue
                        },
                        'geometry': {
                            'type': 'LineString',
                            'coordinates': [
                                [-122.48393028974533, 37.829471820141016],
                                [-122.48395174741744, 37.82940826466351],
                                [-122.48395174741744, 37.829412501697064],
                                [-122.48423874378203, 37.829357420242125],
                                [-122.48422533273697, 37.829361657278575],
                                [-122.48459815979002, 37.8293425906126],
                                [-122.48458743095398, 37.8293447091313],
                                [-122.4847564101219, 37.82932776098012],
                                [-122.48474299907684, 37.829331998018276],
                                [-122.4849334359169, 37.829298101706186],
                                [-122.48492807149889, 37.82930022022615],
                                [-122.48509705066681, 37.82920488676767],
                                [-122.48509168624878, 37.82920912381288],
                                [-122.48520433902739, 37.82905870855876],
                                [-122.48519897460936, 37.82905870855876],
                                [-122.4854403734207, 37.828594749716714],
                                [-122.48543500900269, 37.82860534241688],
                                [-122.48571664094925, 37.82808206121068],
                                [-122.48570591211319, 37.82809689109353],
                                [-122.4858346581459, 37.82797189627337],
                                [-122.48582661151886, 37.82797825194729],
                                [-122.4859634041786, 37.82788503534145],
                                [-122.48595803976059, 37.82788927246246],
                                [-122.48605459928514, 37.82786596829394]
                            ]
                        }
                    }
                ]
            }
        });
        map.addLayer({
            'id': 'lines',
            'type': 'line',
            'source': 'lines',
            'paint': {
                'line-width': 3,
                // Use a get expression (https://maplibre.org/maplibre-style-spec/expressions/#get)
                // to set the line-color to a feature property value.
                'line-color': ['get', 'color']
            }
        });
    });
</script>
</body>
</html>
```

// FILE ./add-deckgl-layer-using-rest-api.html
```
<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Create deck.gl layer using REST API</title>
    <meta property="og:description" content="Create a deck.gl layer as an overlay from a REST API." />
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" href="../../dist/maplibre-gl.css" />
    <script src="../../dist/maplibre-gl-dev.js"></script>
    <script src="https://unpkg.com/deck.gl@8.9.33/dist.min.js"></script>
    <style>
      body {
        margin: 0;
        padding: 0;
      }
      html,
      body,
      #map {
        height: 100%;
      }
      /* Deck.gl layer is added as an overlay, popup needs to be displayed over it */
      .maplibregl-popup {
        z-index: 2;
      }
    </style>
  </head>
  <body>
    <div id="map"></div>
    <script>
      const url = 'https://maps.clockworkmicro.com/streets/v1/style?x-api-key=';
      const apiKey = 'Dr4eW3s233rRkk8I_public';

      const map = new maplibregl.Map({
          container: 'map',
          style: url + apiKey,
          center: [2.343957, 48.862011],
          zoom: 10.5,
      });
      map.addControl(new maplibregl.NavigationControl(), 'top-right');

      // 20 + 1 random colors for all the districts of Paris and outside of the districts
      const colorPalette = [
          [255, 102, 51],
          [255, 179, 153],
          [255, 51, 255],
          [255, 255, 153],
          [0, 179, 230],
          [230, 179, 51],
          [51, 102, 230],
          [153, 153, 102],
          [153, 255, 153],
          [179, 77, 77],
          [128, 179, 0],
          [128, 153, 0],
          [230, 179, 179],
          [102, 128, 179],
          [102, 153, 26],
          [255, 153, 230],
          [204, 255, 26],
          [255, 26, 102],
          [230, 51, 26],
          [51, 255, 204],
          [102, 153, 77],
      ];

      const limit = 100;
      // Sample data source = https://data.iledefrance.fr
      const parisSights = `https://data.iledefrance.fr/api/explore/v2.1/catalog/datasets/principaux-sites-touristiques-en-ile-de-france0/records?limit=${limit}`;

      let layerControl;

      // Add the overlay as a control
      map.on('load', async () => {
          // Fetch the data
          const response = await fetch(parisSights);
          const responseJSON = await response.json();

          const layer = new deck.ScatterplotLayer({
              id: 'scatterplot-layer',
              data: responseJSON.results,
              pickable: true,
              opacity: 0.7,
              stroked: true,
              filled: true,
              radiusMinPixels: 14,
              radiusMaxPixels: 100,
              lineWidthMinPixels: 5,
              // Using appropriate fields for coordinates from the dataset
              getPosition: (d) => [d.geo_point_2d.lon, d.geo_point_2d.lat],
              getFillColor: (d) => {
                  // Filtering by postal code
                  if ('insee' in d && d.insee.startsWith('75')) {
                      // Districts in Paris
                      return colorPalette[parseInt(d.insee.substring(3))];
                  } else {
                      // Out of Paris
                      return colorPalette[20];
                  }
              },
              getLineColor: (d) => [14, 16, 255],
              onClick: (info) => {
                  const {coordinate, object} = info;
                  const description = `<p>${object.nom_carto || 'Unknown'}</p>`;

                  new maplibregl.Popup()
                      .setLngLat(coordinate)
                      .setHTML(description)
                      .addTo(map);
              },
          });

          // Create the overlay
          const overlay = new deck.MapboxOverlay({
              layers: [layer],
          });
          map.addControl(overlay);
      });
    </script>
  </body>
</html>
```

// FILE ./fitbounds.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Fit a map to a bounding box</title>
    <meta property="og:description" content="Fit the map to a specific area, regardless of the pixel size of the map." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<style>
    #fit {
        display: block;
        position: absolute;
        top: 20px;
        left: 50%;
        transform: translate(-50%);
        width: 50%;
        height: 40px;
        padding: 10px;
        border: none;
        border-radius: 3px;
        font-size: 12px;
        text-align: center;
        color: #fff;
        background: #ee8a65;
    }
</style>
<div id="map"></div>
<br />
<button id="fit">Fit to Kenya</button>
<script>
    const map = new maplibregl.Map({
        container: 'map',
        style:
            'https://api.maptiler.com/maps/streets/style.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL',
        center: [-74.5, 40],
        zoom: 9
    });

    document.getElementById('fit').addEventListener('click', () => {
        map.fitBounds([
            [32.958984, -5.353521],
            [43.50585, 5.615985]
        ]);
    });
</script>
</body>
</html>
```

// FILE ./line-gradient.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Create a gradient line using an expression</title>
    <meta property="og:description" content="Use the line-gradient paint property and an expression to visualize distance from the starting point of a line." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<div id="map"></div>

<script>
    const map = (window.map = new maplibregl.Map({
        container: 'map',
        style:
            'https://api.maptiler.com/maps/streets/style.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL',
        center: [-77.035, 38.875],
        zoom: 12
    }));

    const geojson = {
        'type': 'FeatureCollection',
        'features': [
            {
                'type': 'Feature',
                'properties': {},
                'geometry': {
                    'coordinates': [
                        [-77.044211, 38.852924],
                        [-77.045659, 38.860158],
                        [-77.044232, 38.862326],
                        [-77.040879, 38.865454],
                        [-77.039936, 38.867698],
                        [-77.040338, 38.86943],
                        [-77.04264, 38.872528],
                        [-77.03696, 38.878424],
                        [-77.032309, 38.87937],
                        [-77.030056, 38.880945],
                        [-77.027645, 38.881779],
                        [-77.026946, 38.882645],
                        [-77.026942, 38.885502],
                        [-77.028054, 38.887449],
                        [-77.02806, 38.892088],
                        [-77.03364, 38.892108],
                        [-77.033643, 38.899926]
                    ],
                    'type': 'LineString'
                }
            }
        ]
    };

    map.on('load', () => {
        // 'line-gradient' can only be used with GeoJSON sources
        // and the source must have the 'lineMetrics' option set to true
        map.addSource('line', {
            type: 'geojson',
            lineMetrics: true,
            data: geojson
        });

        // the layer must be of type 'line'
        map.addLayer({
            type: 'line',
            source: 'line',
            id: 'line',
            paint: {
                'line-color': 'red',
                'line-width': 14,
                // 'line-gradient' must be specified using an expression
                // with the special 'line-progress' property
                'line-gradient': [
                    'interpolate',
                    ['linear'],
                    ['line-progress'],
                    0,
                    'blue',
                    0.1,
                    'royalblue',
                    0.3,
                    'cyan',
                    0.5,
                    'lime',
                    0.7,
                    'yellow',
                    1,
                    'red'
                ]
            },
            layout: {
                'line-cap': 'round',
                'line-join': 'round'
            }
        });
    });
</script>
</body>
</html>
```

// FILE ./jump-to.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Jump to a series of locations</title>
    <meta property="og:description" content="Use the jumpTo function to showcase multiple locations." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<div id="map"></div>
<script>
    const cities = {
        'type': 'FeatureCollection',
        'features': [
            {
                'type': 'Feature',
                'properties': {},
                'geometry': {
                    'type': 'Point',
                    'coordinates': [100.507, 13.745]
                }
            },
            {
                'type': 'Feature',
                'properties': {},
                'geometry': {
                    'type': 'Point',
                    'coordinates': [98.993, 18.793]
                }
            },
            {
                'type': 'Feature',
                'properties': {},
                'geometry': {
                    'type': 'Point',
                    'coordinates': [99.838, 19.924]
                }
            },
            {
                'type': 'Feature',
                'properties': {},
                'geometry': {
                    'type': 'Point',
                    'coordinates': [102.812, 17.408]
                }
            },
            {
                'type': 'Feature',
                'properties': {},
                'geometry': {
                    'type': 'Point',
                    'coordinates': [100.458, 7.001]
                }
            },
            {
                'type': 'Feature',
                'properties': {},
                'geometry': {
                    'type': 'Point',
                    'coordinates': [100.905, 12.935]
                }
            }
        ]
    };

    const map = new maplibregl.Map({
        container: 'map',
        style:
            'https://api.maptiler.com/maps/streets/style.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL',
        center: [100.507, 13.745],
        zoom: 9
    });

    map.on('load', () => {
        cities.features.forEach((city, index) => {
            setTimeout(() => {
                map.jumpTo({center: city.geometry.coordinates});
            }, 2000 * index);
        });
    });
</script>
</body>
</html>
```

// FILE ./timeline-animation.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Create a time slider</title>
    <meta property="og:description" content="Visualize earthquakes with a range slider." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<style>
    .map-overlay {
        font: 12px/20px 'Helvetica Neue', Arial, Helvetica, sans-serif;
        position: absolute;
        width: 25%;
        top: 0;
        left: 0;
        padding: 10px;
    }

    .map-overlay .map-overlay-inner {
        background-color: #fff;
        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
        border-radius: 3px;
        padding: 10px;
        margin-bottom: 10px;
    }

    .map-overlay h2 {
        line-height: 24px;
        display: block;
        margin: 0 0 10px;
    }

    .map-overlay .legend .bar {
        height: 10px;
        width: 100%;
        background: linear-gradient(to right, #fca107, #7f3121);
    }

    .map-overlay input {
        background-color: transparent;
        display: inline-block;
        width: 100%;
        position: relative;
        margin: 0;
        cursor: ew-resize;
    }
</style>

<div id="map"></div>

<div class="map-overlay top">
    <div class="map-overlay-inner">
        <h2>Significant earthquakes in 2015</h2>
        <label id="month" for="slider"></label>
        <input id="slider" type="range" min="0" max="11" step="1" value="0" />
    </div>
    <div class="map-overlay-inner">
        <div id="legend" class="legend">
            <div class="bar"></div>
            <div>Magnitude (m)</div>
        </div>
    </div>
</div>

<script src="https://d3js.org/d3.v3.min.js" charset="utf-8"></script>
<script>
    const map = new maplibregl.Map({
        container: 'map',
        style:
            'https://api.maptiler.com/maps/streets/style.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL',
        center: [31.4606, 20.7927],
        zoom: 0.5
    });

    const months = [
        'January',
        'February',
        'March',
        'April',
        'May',
        'June',
        'July',
        'August',
        'September',
        'October',
        'November',
        'December'
    ];

    function filterBy(month) {
        const filters = ['==', 'month', month];
        map.setFilter('earthquake-circles', filters);
        map.setFilter('earthquake-labels', filters);

        // Set the label to the month
        document.getElementById('month').textContent = months[month];
    }

    map.on('load', () => {
        // Data courtesy of https://www.usgs.gov/programs/earthquake-hazards
        // Query for significant earthquakes in 2015 URL request looked like this:
        // https://earthquake.usgs.gov/fdsnws/event/1/query
        //    ?format=geojson
        //    &starttime=2015-01-01
        //    &endtime=2015-12-31
        //    &minmagnitude=6'
        //
        // Here we're using d3 to help us make the ajax request but you can use
        // Any request method (library or otherwise) you wish.
        d3.json(
            'https://maplibre.org/maplibre-gl-js/docs/assets/significant-earthquakes-2015.geojson',
            (err, data) => {
                if (err) throw err;

                // Create a month property value based on time
                // used to filter against.
                data.features = data.features.map((d) => {
                    d.properties.month = new Date(d.properties.time).getMonth();
                    return d;
                });

                map.addSource('earthquakes', {
                    'type': 'geojson',
                    data
                });

                map.addLayer({
                    'id': 'earthquake-circles',
                    'type': 'circle',
                    'source': 'earthquakes',
                    'paint': {
                        'circle-color': [
                            'interpolate',
                            ['linear'],
                            ['get', 'mag'],
                            6,
                            '#FCA107',
                            8,
                            '#7F3121'
                        ],
                        'circle-opacity': 0.75,
                        'circle-radius': [
                            'interpolate',
                            ['linear'],
                            ['get', 'mag'],
                            6,
                            20,
                            8,
                            40
                        ]
                    }
                });

                map.addLayer({
                    'id': 'earthquake-labels',
                    'type': 'symbol',
                    'source': 'earthquakes',
                    'layout': {
                        'text-field': [
                            'concat',
                            ['to-string', ['get', 'mag']],
                            'm'
                        ],
                        'text-font': [
                            'Open Sans Bold',
                            'Arial Unicode MS Bold'
                        ],
                        'text-size': 12
                    },
                    'paint': {
                        'text-color': 'rgba(0,0,0,0.5)'
                    }
                });

                // Set filter to first month of the year
                // 0 = January
                filterBy(0);

                document
                    .getElementById('slider')
                    .addEventListener('input', (e) => {
                        const month = parseInt(e.target.value, 10);
                        filterBy(month);
                    });
            }
        );
    });
</script>
</body>
</html>
```

// FILE ./add-3d-model-babylon.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Add a 3D model with babylon.js</title>
    <meta property="og:description" content="Use a custom style layer with babylon.js to add a 3D model to the map." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<script src="https://unpkg.com/babylonjs@5.42.2/babylon.js"></script>
<script src="https://unpkg.com/babylonjs-loaders@5.42.2/babylonjs.loaders.min.js"></script>
<div id="map"></div>
<script>
    const BABYLON = window.BABYLON;

    const map = (window.map = new maplibregl.Map({
        container: 'map',
        style: 'https://api.maptiler.com/maps/basic/style.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL',
        zoom: 18,
        center: [148.9819, -35.3981],
        pitch: 60,
        canvasContextAttributes: {antialias: true} // create the gl context with MSAA antialiasing, so custom layers are antialiased
    }));

    // World matrix parameters
    const worldOrigin = [148.9819, -35.39847];
    const worldAltitude = 0;

    // Maplibre.js default coordinate system (no rotations)
    // +x east, -y north, +z up
    //var worldRotate = [0, 0, 0];

    // Babylon.js default coordinate system
    // +x east, +y up, +z north
    const worldRotate = [Math.PI / 2, 0, 0];

    // Calculate mercator coordinates and scale
    const worldOriginMercator = maplibregl.MercatorCoordinate.fromLngLat(
        worldOrigin,
        worldAltitude
    );
    const worldScale = worldOriginMercator.meterInMercatorCoordinateUnits();

    // Calculate world matrix
    const worldMatrix = BABYLON.Matrix.Compose(
        new BABYLON.Vector3(worldScale, worldScale, worldScale),
        BABYLON.Quaternion.FromEulerAngles(
            worldRotate[0],
            worldRotate[1],
            worldRotate[2]
        ),
        new BABYLON.Vector3(
            worldOriginMercator.x,
            worldOriginMercator.y,
            worldOriginMercator.z
        )
    );

    // configuration of the custom layer for a 3D model per the CustomLayerInterface
    const customLayer = {
        id: '3d-model',
        type: 'custom',
        renderingMode: '3d',
        onAdd (map, gl) {
            this.engine = new BABYLON.Engine(
                gl,
                true,
                {
                    useHighPrecisionMatrix: true // Important to prevent jitter at mercator scale
                },
                true
            );
            this.scene = new BABYLON.Scene(this.engine);
            /**
            * optionally add
            * this.scene.autoClearDepthAndStencil = false
            * and for renderingGroupIds set this individually via
            * this.scene.setRenderingAutoClearDepthStencil(1,false)
            * to allow blending with maplibre scene
            * as documented in https://doc.babylonjs.com/features/featuresDeepDive/scene/optimize_your_scene#reducing-calls-to-glclear
            */
            this.scene.autoClear = false;
            /**
            * use detachControl if you only want to interact with maplibre-gl and do not need pointer events of babylonjs.
            * alternatively exchange this.scene.detachControl() with the following two lines, they will allow bubbling up events to maplibre-gl.
            * this.scene.preventDefaultOnPointerDown = false
            * this.scene.preventDefaultOnPointerUp = false
            * https://doc.babylonjs.com/typedoc/classes/BABYLON.Scene#preventDefaultOnPointerDown
            */
            this.scene.detachControl();

            this.scene.beforeRender = () => {
                this.engine.wipeCaches(true);
            };

            // create simple camera (will have its project matrix manually calculated)
            this.camera = new BABYLON.Camera(
                'Camera',
                new BABYLON.Vector3(0, 0, 0),
                this.scene
            );

            // create simple light
            const light = new BABYLON.HemisphericLight(
                'light1',
                new BABYLON.Vector3(0, 0, 100),
                this.scene
            );
            light.intensity = 0.7;

            // Add debug axes viewer, positioned at origin, 10 meter axis lengths
            new BABYLON.AxesViewer(this.scene, 10);

            // load GLTF model in to the scene
            BABYLON.SceneLoader.LoadAssetContainerAsync(
                'https://maplibre.org/maplibre-gl-js/docs/assets/34M_17/34M_17.gltf',
                '',
                this.scene
            ).then((modelContainer) => {
                modelContainer.addAllToScene();

                const rootMesh = modelContainer.createRootMesh();

                // If using maplibre.js coordinate system (+z up)
                //rootMesh.rotation.x = Math.PI/2

                // Create a second mesh
                const rootMesh2 = rootMesh.clone();

                // Position in babylon.js coordinate system
                rootMesh2.position.x = 25; // +east, meters
                rootMesh2.position.z = 25; // +north, meters
            });

            this.map = map;
        },
        render (gl, args) {
            const cameraMatrix = BABYLON.Matrix.FromArray(args.defaultProjectionData.mainMatrix);

            // world-view-projection matrix
            const wvpMatrix = worldMatrix.multiply(cameraMatrix);

            this.camera.freezeProjectionMatrix(wvpMatrix);

            this.scene.render(false);
            this.map.triggerRepaint();
        }
    };

    map.on('style.load', () => {
        map.addLayer(customLayer);
    });
</script>
</body>
</html>
```

// FILE ./flyto-options.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Slowly fly to a location</title>
    <meta property="og:description" content="Use flyTo with flyOptions to slowly zoom to a location." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<style>
    #fly {
        display: block;
        position: absolute;
        top: 20px;
        left: 50%;
        transform: translate(-50%);
        width: 50%;
        height: 40px;
        padding: 10px;
        border: none;
        border-radius: 3px;
        font-size: 12px;
        text-align: center;
        color: #fff;
        background: #ee8a65;
    }
</style>
<div id="map"></div>
<br />
<button id="fly">Fly</button>
<script>
    const start = [-74.5, 40];
    const end = [74.5, 40];
    const map = new maplibregl.Map({
        container: 'map',
        style:
            'https://api.maptiler.com/maps/streets/style.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL',
        center: start,
        zoom: 9
    });

    let isAtStart = true;

    document.getElementById('fly').addEventListener('click', () => {
        // depending on whether we're currently at point a or b, aim for
        // point a or b
        const target = isAtStart ? end : start;

        // and now we're at the opposite point
        isAtStart = !isAtStart;

        map.flyTo({
            // These options control the ending camera position: centered at
            // the target, at zoom level 9, and north up.
            center: target,
            zoom: 9,
            bearing: 0,

            // These options control the flight curve, making it move
            // slowly and zoom out almost completely before starting
            // to pan.
            speed: 0.2, // make the flying slow
            curve: 1, // change the speed at which it zooms out

            // This can be any easing function: it takes a number between
            // 0 and 1 and returns another number between 0 and 1.
            easing (t) {
                return t;
            },

            // this animation is considered essential with respect to prefers-reduced-motion
            essential: true
        });
    });
</script>
</body>
</html>
```

// FILE ./restrict-bounds.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Restrict map panning to an area</title>
    <meta property="og:description" content="Prevent a map from being panned to a different place by setting maxBounds." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<div id="map"></div>
<script>
    // Set bounds to New York, New York
    const bounds = [
        [-74.04728500751165, 40.68392799015035], // Southwest coordinates
        [-73.91058699000139, 40.87764500765852] // Northeast coordinates
    ];

    const map = new maplibregl.Map({
        container: 'map',
        style:
            'https://api.maptiler.com/maps/streets/style.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL',
        center: [-73.9978, 40.7209],
        zoom: 13,
        maxBounds: bounds // Sets bounds as max
    });
</script>
</body>
</html>
```

// FILE ./attribution-position.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Change the default position for attribution</title>
    <meta property="og:description" content="Place attribution in the top-left position when initializing a map." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<div id="map"></div>

<script>
    const map = new maplibregl.Map({
        container: 'map',
        style:
            'https://api.maptiler.com/maps/streets/style.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL',
        center: [-77.04, 38.907],
        zoom: 11.15,
        attributionControl: false
    });
    map.addControl(new maplibregl.AttributionControl(), 'top-left');
</script>
</body>
</html>
```

// FILE ./maplibre-gl-terradraw.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Draw geometries with terra-draw</title>
    <meta property="og:description" content="Use maplibre-gl-terradraw to draw a geometry in various forms such as point, line or polygon on your map." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>

<script src="https://cdn.jsdelivr.net/npm/@watergis/maplibre-gl-terradraw@1.0.1/dist/maplibre-gl-terradraw.umd.js"></script>
<link
    rel="stylesheet"
    href="https://cdn.jsdelivr.net/npm/@watergis/maplibre-gl-terradraw@1.0.1/dist/maplibre-gl-terradraw.css"
/>
<div id="map"></div>

<script>
    const map = new maplibregl.Map({
        container: 'map', // container id
        style:
            'https://api.maptiler.com/maps/streets/style.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL', //hosted style id
        center: [-91.874, 42.76], // starting position
        zoom: 12 // starting zoom
    });

    // By default, all terra-draw drawing modes are enabled.
    // you can disable some of modes in the constructor options if you want.
    const draw = new MaplibreTerradrawControl.MaplibreTerradrawControl({
        modes: [
            // 'render', comment this to always show drawing tool
            'point',
            'linestring',
            'polygon',
            'rectangle',
            'circle',
            'freehand',
            'angled-rectangle',
            'sensor',
            'sector',
            'select',
            'delete-selection',
            'delete',
            'download'
        ],
        open: true,
    });
    map.addControl(draw, 'top-left');
</script>
</body>
</html>
```

// FILE ./animate-a-line.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Animate a line</title>
    <meta property="og:description" content="Animate a line by updating a GeoJSON source on each frame." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<style>
    button {
        position: absolute;
        top: 0;
        margin: 20px;
    }

    #pause::after {
        content: 'Pause';
    }

    #pause.pause::after {
        content: 'Play';
    }
</style>
<div id="map"></div>
<button id="pause"></button>
<script>
    const map = new maplibregl.Map({
        container: 'map',
        style:
            'https://api.maptiler.com/maps/streets/style.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL',
        center: [0, 0],
        zoom: 0.5
    });

    // Create a GeoJSON source with an empty lineString.
    const geojson = {
        'type': 'FeatureCollection',
        'features': [
            {
                'type': 'Feature',
                'geometry': {
                    'type': 'LineString',
                    'coordinates': [[0, 0]]
                }
            }
        ]
    };

    const speedFactor = 30; // number of frames per longitude degree
    let animation; // to store and cancel the animation
    let startTime = 0;
    let progress = 0; // progress = timestamp - startTime
    let resetTime = false; // indicator of whether time reset is needed for the animation
    const pauseButton = document.getElementById('pause');

    map.on('load', () => {
        map.addSource('line', {
            'type': 'geojson',
            'data': geojson
        });

        // add the line which will be modified in the animation
        map.addLayer({
            'id': 'line-animation',
            'type': 'line',
            'source': 'line',
            'layout': {
                'line-cap': 'round',
                'line-join': 'round'
            },
            'paint': {
                'line-color': '#ed6498',
                'line-width': 5,
                'line-opacity': 0.8
            }
        });

        startTime = performance.now();

        animateLine();

        // click the button to pause or play
        pauseButton.addEventListener('click', () => {
            pauseButton.classList.toggle('pause');
            if (pauseButton.classList.contains('pause')) {
                cancelAnimationFrame(animation);
            } else {
                resetTime = true;
                animateLine();
            }
        });

        // reset startTime and progress once the tab loses or gains focus
        // requestAnimationFrame also pauses on hidden tabs by default
        document.addEventListener('visibilitychange', () => {
            resetTime = true;
        });

        // animated in a circle as a sine wave along the map.
        function animateLine(timestamp) {
            if (resetTime) {
                // resume previous progress
                startTime = performance.now() - progress;
                resetTime = false;
            } else {
                progress = timestamp - startTime;
            }

            // restart if it finishes a loop
            if (progress > speedFactor * 360) {
                startTime = timestamp;
                geojson.features[0].geometry.coordinates = [];
            } else {
                const x = progress / speedFactor;
                // draw a sine wave with some math.
                const y = Math.sin((x * Math.PI) / 90) * 40;
                // append new coordinates to the lineString
                geojson.features[0].geometry.coordinates.push([x, y]);
                // then update the map
                map.getSource('line').setData(geojson);
            }
            // Request the next frame of the animation.
            animation = requestAnimationFrame(animateLine);
        }
    });
</script>
</body>
</html>
```

// FILE ./popup.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Display a popup</title>
    <meta property="og:description" content="Add a popup to the map." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<div id="map"></div>
<script>
    const map = new maplibregl.Map({
        container: 'map',
        style:
            'https://api.maptiler.com/maps/streets/style.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL',
        center: [-96, 37.8],
        zoom: 3
    });

    const popup = new maplibregl.Popup({closeOnClick: false})
        .setLngLat([-96, 37.8])
        .setHTML('<h1>Hello World!</h1>')
        .addTo(map);
</script>
</body>
</html>
```

// FILE ./disable-rotation.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Disable map rotation</title>
    <meta property="og:description" content="Prevent users from rotating a map." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<div id="map"></div>
<script>
    const map = new maplibregl.Map({
        container: 'map', // container id
        style:
            'https://api.maptiler.com/maps/streets/style.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL', //stylesheet location
        center: [-122.65, 45.52], // starting position
        zoom: 9 // starting zoom
    });

    // disable map rotation using right click + drag
    map.dragRotate.disable();

    // disable map rotation using keyboard
    map.keyboard.disable();

    // disable map rotation using touch rotation gesture
    map.touchZoomRotate.disableRotation();
</script>
</body>
</html>
```

// FILE ./3d-extrusion-floorplan.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Extrude polygons for 3D indoor mapping</title>
    <meta property="og:description" content="Create a 3D indoor map with the fill-extrude-height paint property." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<div id="map"></div>
<script>
    const map = new maplibregl.Map({
        container: 'map',
        style: {
            'id': 'raster',
            'version': 8,
            'name': 'Raster tiles',
            'center': [0, 0],
            'zoom': 0,
            'sources': {
                'raster-tiles': {
                    'type': 'raster',
                    'tiles': ['https://tile.openstreetmap.org/{z}/{x}/{y}.png'],
                    'tileSize': 256,
                    'minzoom': 0,
                    'maxzoom': 19
                }
            },
            'layers': [
                {
                    'id': 'background',
                    'type': 'background',
                    'paint': {
                        'background-color': '#e0dfdf'
                    }
                },
                {
                    'id': 'simple-tiles',
                    'type': 'raster',
                    'source': 'raster-tiles'
                }
            ]
        },
        center: [-87.61694, 41.86625],
        zoom: 15.99,
        pitch: 40,
        bearing: 20,
        canvasContextAttributes: {antialias: true}
    });

    map.on('load', () => {
        map.addSource('floorplan', {
            // GeoJSON Data source used in vector tiles, documented at
            // https://gist.github.com/ryanbaumann/a7d970386ce59d11c16278b90dde094d
            'type': 'geojson',
            'data': 'https://maplibre.org/maplibre-gl-js/docs/assets/indoor-3d-map.geojson'
        });
        map.addLayer({
            'id': 'room-extrusion',
            'type': 'fill-extrusion',
            'source': 'floorplan',
            'paint': {
                // See the MapLibre Style Specification for details on data expressions.
                // https://maplibre.org/maplibre-style-spec/expressions/

                // Get the fill-extrusion-color from the source 'color' property.
                'fill-extrusion-color': ['get', 'color'],

                // Get fill-extrusion-height from the source 'height' property.
                'fill-extrusion-height': ['get', 'height'],

                // Get fill-extrusion-base from the source 'base_height' property.
                'fill-extrusion-base': ['get', 'base_height'],

                // Make extrusions slightly opaque for see through indoor walls.
                'fill-extrusion-opacity': 0.5
            }
        });
    });
</script>
</body>
</html>
```

// FILE ./drag-a-marker.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Create a draggable Marker</title>
    <meta property="og:description" content="Drag the marker to a new location on a map and populate its coordinates in a display." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<style>
    .coordinates {
        background: rgba(0, 0, 0, 0.5);
        color: #fff;
        position: absolute;
        bottom: 40px;
        left: 10px;
        padding: 5px 10px;
        margin: 0;
        font-size: 11px;
        line-height: 18px;
        border-radius: 3px;
        display: none;
    }
</style>

<div id="map"></div>
<pre id="coordinates" class="coordinates"></pre>

<script>
    const coordinates = document.getElementById('coordinates');
    const map = new maplibregl.Map({
        container: 'map',
        style:
            'https://api.maptiler.com/maps/streets/style.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL',
        center: [0, 0],
        zoom: 2
    });

    const marker = new maplibregl.Marker({draggable: true})
        .setLngLat([0, 0])
        .addTo(map);

    function onDragEnd() {
        const lngLat = marker.getLngLat();
        coordinates.style.display = 'block';
        coordinates.innerHTML =
            `Longitude: ${lngLat.lng}<br />Latitude: ${lngLat.lat}`;
    }

    marker.on('dragend', onDragEnd);
</script>
</body>
</html>
```

// FILE ./add-3d-model.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Add a 3D model using three.js</title>
    <meta property="og:description" content="Use a custom style layer with three.js to add a 3D model to the map." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<script type="importmap">
    {
        "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.169.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.169.0/examples/jsm/"
        }
    }
</script>
<div id="map"></div>

<script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

    const map = new maplibregl.Map({
        container: 'map',
        style:
            'https://api.maptiler.com/maps/basic/style.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL',
        zoom: 18,
        center: [148.9819, -35.3981],
        pitch: 60,
        canvasContextAttributes: {antialias: true} // create the gl context with MSAA antialiasing, so custom layers are antialiased
    });

    // parameters to ensure the model is georeferenced correctly on the map
    const modelOrigin = [148.9819, -35.39847];
    const modelAltitude = 0;
    const modelRotate = [Math.PI / 2, 0, 0];

    const modelAsMercatorCoordinate = maplibregl.MercatorCoordinate.fromLngLat(
        modelOrigin,
        modelAltitude
    );

    // transformation parameters to position, rotate and scale the 3D model onto the map
    const modelTransform = {
        translateX: modelAsMercatorCoordinate.x,
        translateY: modelAsMercatorCoordinate.y,
        translateZ: modelAsMercatorCoordinate.z,
        rotateX: modelRotate[0],
        rotateY: modelRotate[1],
        rotateZ: modelRotate[2],
        /* Since our 3D model is in real world meters, a scale transform needs to be
        * applied since the CustomLayerInterface expects units in MercatorCoordinates.
        */
        scale: modelAsMercatorCoordinate.meterInMercatorCoordinateUnits()
    };


    // configuration of the custom layer for a 3D model per the CustomLayerInterface
    const customLayer = {
        id: '3d-model',
        type: 'custom',
        renderingMode: '3d',
        onAdd (map, gl) {
            this.camera = new THREE.Camera();
            this.scene = new THREE.Scene();

            // create two three.js lights to illuminate the model
            const directionalLight = new THREE.DirectionalLight(0xffffff);
            directionalLight.position.set(0, -70, 100).normalize();
            this.scene.add(directionalLight);

            const directionalLight2 = new THREE.DirectionalLight(0xffffff);
            directionalLight2.position.set(0, 70, 100).normalize();
            this.scene.add(directionalLight2);

            // use the three.js GLTF loader to add the 3D model to the three.js scene
            const loader = new GLTFLoader();
            loader.load(
                'https://maplibre.org/maplibre-gl-js/docs/assets/34M_17/34M_17.gltf',
                (gltf) => {
                    this.scene.add(gltf.scene);
                }
            );
            this.map = map;

            // use the MapLibre GL JS map canvas for three.js
            this.renderer = new THREE.WebGLRenderer({
                canvas: map.getCanvas(),
                context: gl,
                antialias: true
            });

            this.renderer.autoClear = false;
        },
        render (gl, args) {
            const rotationX = new THREE.Matrix4().makeRotationAxis(
                new THREE.Vector3(1, 0, 0),
                modelTransform.rotateX
            );
            const rotationY = new THREE.Matrix4().makeRotationAxis(
                new THREE.Vector3(0, 1, 0),
                modelTransform.rotateY
            );
            const rotationZ = new THREE.Matrix4().makeRotationAxis(
                new THREE.Vector3(0, 0, 1),
                modelTransform.rotateZ
            );

            const m = new THREE.Matrix4().fromArray(args.defaultProjectionData.mainMatrix);
            const l = new THREE.Matrix4()
                .makeTranslation(
                    modelTransform.translateX,
                    modelTransform.translateY,
                    modelTransform.translateZ
                )
                .scale(
                    new THREE.Vector3(
                        modelTransform.scale,
                        -modelTransform.scale,
                        modelTransform.scale
                    )
                )
                .multiply(rotationX)
                .multiply(rotationY)
                .multiply(rotationZ);

            // Alternatively, you can use this API to get the correct model matrix.
            // It will work regardless of current projection.
            // Also see the example "globe-3d-model.html".
            //
            // const modelMatrix = args.getMatrixForModel(modelOrigin, modelAltitude);
            // const m = new THREE.Matrix4().fromArray(matrix);
            // const l = new THREE.Matrix4().fromArray(modelMatrix);

            this.camera.projectionMatrix = m.multiply(l);
            this.renderer.resetState();
            this.renderer.render(this.scene, this.camera);
            this.map.triggerRepaint();
        }
    };

    map.on('style.load', () => {
        map.addLayer(customLayer);
    });
</script>
</body>
</html>
```

// FILE ./hillshade-simple.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Add a hillshade layer</title>
    <meta property="og:description" content="Add a simple hillshade layer." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<div id='map'></div>

<script>
    const map = window.map = new maplibregl.Map({
        container: 'map',
        zoom: 10,
        center: [11.491, 47.274],
        pitch: 0,
        renderWorldCopies: false,
        hash: true,
        style: {
            version: 8,
            sources: {
                hillshadeSource: {
                    type: 'raster-dem',
                    url: 'https://demotiles.maplibre.org/terrain-tiles/tiles.json',
                    tileSize: 256
                }
            },
            layers: [
                {
                    id: 'hillshade',
                    type: 'hillshade',
                    source: 'hillshadeSource',
                    paint: {
                        'hillshade-method': 'standard',
                        'hillshade-illumination-altitude': 45,
                        'hillshade-illumination-direction': 315,
                        'hillshade-shadow-color': '#000000',
                        'hillshade-highlight-color': '#FFFFFF',
                        'hillshade-accent-color': '#000000',
                        'hillshade-exaggeration': 0.5
                    }
                }
            ]
        },
        maxZoom: 18,
        maxPitch: 85
    });
</script>

</body>
</html>
```

// FILE ./animate-marker.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Animate a marker</title>
    <meta property="og:description" content="Animate the position of a marker by updating its location on each frame." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<div id="map"></div>
<script>
    const map = new maplibregl.Map({
        container: 'map',
        style:
            'https://api.maptiler.com/maps/streets/style.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL',
        center: [0, 0],
        zoom: 2
    });

    const marker = new maplibregl.Marker();

    function animateMarker(timestamp) {
        const radius = 20;

        // Update the data to a new position based on the animation timestamp. The
        // divisor in the expression `timestamp / 1000` controls the animation speed.
        marker.setLngLat([
            Math.cos(timestamp / 1000) * radius,
            Math.sin(timestamp / 1000) * radius
        ]);

        // Ensure it's added to the map. This is safe to call if it's already added.
        marker.addTo(map);

        // Request the next frame of the animation.
        requestAnimationFrame(animateMarker);
    }

    // Start the animation.
    requestAnimationFrame(animateMarker);
</script>
</body>
</html>
```

// FILE ./set-perspective.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Set pitch and bearing</title>
    <meta property="og:description" content="Initialize a map with pitch and bearing camera options." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<div id="map"></div>
<script>
    const map = new maplibregl.Map({
        container: 'map',
        style:
            'https://api.maptiler.com/maps/streets/style.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL',
        // camera options properties
        center: [-73.5804, 45.53483],
        pitch: 60, // pitch in degrees
        bearing: -60, // bearing in degrees
        zoom: 10
    });
</script>
</body>
</html>
```

// FILE ./3d-terrain.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>3D Terrain</title>
    <meta property="og:description" content="Go beyond hillshade and show elevation in actual 3D." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<div id="map"></div>
<script>
    const map = (window.map = new maplibregl.Map({
        container: 'map',
        zoom: 12,
        center: [11.39085, 47.27574],
        pitch: 70,
        hash: true,
        style: {
            version: 8,
            sources: {
                osm: {
                    type: 'raster',
                    tiles: ['https://a.tile.openstreetmap.org/{z}/{x}/{y}.png'],
                    tileSize: 256,
                    attribution: '&copy; OpenStreetMap Contributors',
                    maxzoom: 19
                },
                // Use a different source for terrain and hillshade layers, to improve render quality
                terrainSource: {
                    type: 'raster-dem',
                    url: 'https://demotiles.maplibre.org/terrain-tiles/tiles.json',
                    tileSize: 256
                },
                hillshadeSource: {
                    type: 'raster-dem',
                    url: 'https://demotiles.maplibre.org/terrain-tiles/tiles.json',
                    tileSize: 256
                }
            },
            layers: [
                {
                    id: 'osm',
                    type: 'raster',
                    source: 'osm'
                },
                {
                    id: 'hills',
                    type: 'hillshade',
                    source: 'hillshadeSource',
                    layout: {visibility: 'visible'},
                    paint: {'hillshade-shadow-color': '#473B24'}
                }
            ],
            terrain: {
                source: 'terrainSource',
                exaggeration: 1
            },
            sky: {}
        },
        maxZoom: 18,
        maxPitch: 85
    }));

    map.addControl(
        new maplibregl.NavigationControl({
            visualizePitch: true,
            showZoom: true,
            showCompass: true
        })
    );

    map.addControl(
        new maplibregl.TerrainControl({
            source: 'terrainSource',
            exaggeration: 1
        })
    );
</script>
</body>
</html>
```

// FILE ./add-image-animated.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Add an animated icon to the map</title>
    <meta property="og:description" content="Add an animated icon to the map that was generated at runtime with the Canvas API." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<div id="map"></div>

<script>
    const map = new maplibregl.Map({
        container: 'map',
        style:
            'https://api.maptiler.com/maps/streets/style.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL'
    });

    const size = 200;

    // implementation of StyleImageInterface to draw a pulsing dot icon on the map
    // Search for StyleImageInterface in https://maplibre.org/maplibre-gl-js/docs/API/
    const pulsingDot = {
        width: size,
        height: size,
        data: new Uint8Array(size * size * 4),

        // get rendering context for the map canvas when layer is added to the map
        onAdd () {
            const canvas = document.createElement('canvas');
            canvas.width = this.width;
            canvas.height = this.height;
            this.context = canvas.getContext('2d');
        },

        // called once before every frame where the icon will be used
        render () {
            const duration = 1000;
            const t = (performance.now() % duration) / duration;

            const radius = (size / 2) * 0.3;
            const outerRadius = (size / 2) * 0.7 * t + radius;
            const context = this.context;

            // draw outer circle
            context.clearRect(0, 0, this.width, this.height);
            context.beginPath();
            context.arc(
                this.width / 2,
                this.height / 2,
                outerRadius,
                0,
                Math.PI * 2
            );
            context.fillStyle = `rgba(255, 200, 200,${1 - t})`;
            context.fill();

            // draw inner circle
            context.beginPath();
            context.arc(
                this.width / 2,
                this.height / 2,
                radius,
                0,
                Math.PI * 2
            );
            context.fillStyle = 'rgba(255, 100, 100, 1)';
            context.strokeStyle = 'white';
            context.lineWidth = 2 + 4 * (1 - t);
            context.fill();
            context.stroke();

            // update this image's data with data from the canvas
            this.data = context.getImageData(
                0,
                0,
                this.width,
                this.height
            ).data;

            // continuously repaint the map, resulting in the smooth animation of the dot
            map.triggerRepaint();

            // return `true` to let the map know that the image was updated
            return true;
        }
    };

    map.on('load', () => {
        map.addImage('pulsing-dot', pulsingDot, {pixelRatio: 2});

        map.addSource('points', {
            'type': 'geojson',
            'data': {
                'type': 'FeatureCollection',
                'features': [
                    {
                        'type': 'Feature',
                        'geometry': {
                            'type': 'Point',
                            'coordinates': [0, 0]
                        }
                    }
                ]
            }
        });
        map.addLayer({
            'id': 'points',
            'type': 'symbol',
            'source': 'points',
            'layout': {
                'icon-image': 'pulsing-dot'
            }
        });
    });
</script>
</body>
</html>
```

// FILE ./variable-offset-label-placement.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Variable label placement with offset</title>
    <meta property="og:description" content="Use text-variable-anchor-offset to allow high priority labels to shift position to stay on the map." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<div id="map"></div>

<script>
    const places = {
        'type': 'FeatureCollection',
        'features': [
            {
                'type': 'Feature',
                'properties': {
                    'description': 'Ford\'s Theater',
                    'icon': 'theatre'
                },
                'geometry': {
                    'type': 'Point',
                    'coordinates': [-77.038659, 38.931567]
                }
            },
            {
                'type': 'Feature',
                'properties': {
                    'description': 'The Gaslight',
                    'icon': 'theatre'
                },
                'geometry': {
                    'type': 'Point',
                    'coordinates': [-77.003168, 38.894651]
                }
            },
            {
                'type': 'Feature',
                'properties': {
                    'description': 'Horrible Harry\'s',
                    'icon': 'bar'
                },
                'geometry': {
                    'type': 'Point',
                    'coordinates': [-77.090372, 38.881189]
                }
            },
            {
                'type': 'Feature',
                'properties': {
                    'description': 'Bike Party',
                    'icon': 'bicycle'
                },
                'geometry': {
                    'type': 'Point',
                    'coordinates': [-77.052477, 38.943951]
                }
            },
            {
                'type': 'Feature',
                'properties': {
                    'description': 'Rockabilly Rockstars',
                    'icon': 'music'
                },
                'geometry': {
                    'type': 'Point',
                    'coordinates': [-77.031706, 38.914581]
                }
            },
            {
                'type': 'Feature',
                'properties': {
                    'description': 'District Drum Tribe',
                    'icon': 'music'
                },
                'geometry': {
                    'type': 'Point',
                    'coordinates': [-77.020945, 38.878241]
                }
            },
            {
                'type': 'Feature',
                'properties': {
                    'description': 'Motown Memories',
                    'icon': 'music'
                },
                'geometry': {
                    'type': 'Point',
                    'coordinates': [-77.007481, 38.876516]
                }
            }
        ]
    };

    const map = new maplibregl.Map({
        container: 'map',
        style: 'https://api.maptiler.com/maps/streets/style.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL',
        center: [-77.04, 38.907],
        zoom: 11.15
    });

    map.on('load', () => {
        // Add a GeoJSON source containing place coordinates and information.
        map.addSource('places', {
            'type': 'geojson',
            'data': places
        });

        map.addLayer({
            'id': 'poi-labels',
            'type': 'symbol',
            'source': 'places',
            'layout': {
                'text-field': ['get', 'description'],
                'text-variable-anchor-offset': ['top', [0, 1], 'bottom', [0, -2], 'left', [1, 0], 'right', [-2, 0]],
                'text-justify': 'auto',
                'icon-image': ['concat', ['get', 'icon'], '_15']
            }
        });

        map.rotateTo(180, {duration: 10000});
    });
</script>
</body>
</html>
```

// FILE ./live-geojson.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Add live realtime data</title>
    <meta property="og:description" content="Use realtime GeoJSON data streams to move a symbol on your map." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<div id="map"></div>

<script>
    const map = new maplibregl.Map({
        container: 'map',
        style:
            'https://api.maptiler.com/maps/streets/style.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL',
        zoom: 0
    });

    map.on('load', () => {
        window.setInterval(() => {
            // Make a GET request to get two random numbers
            fetch('https://www.random.org/decimal-fractions/?num=2&dec=10&col=1&format=plain&rnd=new')
                .then(r => r.text())
                .then(text => {
                    // Takes the two random numbers between 0 and 1 and converts them to degrees
                    const coordinates = text.split('
').map(l => (Number(l) * 180) - 90);
                    const json = {
                        type: 'Feature',
                        geometry: {
                            type: 'Point',
                            coordinates
                        }
                    };
                    // Update the drone symbol's location on the map
                    map.getSource('drone').setData(json);

                    // Fly the map to the drone's current location
                    map.flyTo({
                        center: json.geometry.coordinates,
                        speed: 0.5
                    });
                });
        }, 2000);

        // Set initial location at (0,0).
        map.addSource('drone', {type: 'geojson', data: {
            type: 'Feature',
            geometry: {
                type: 'Point',
                coordinates: [0, 0]
            }
        }});
        map.addLayer({
            'id': 'drone',
            'type': 'symbol',
            'source': 'drone',
            'layout': {
                'icon-image': 'rocket_15'
            }
        });
    });
</script>
</body>
</html>
```

// FILE ./color-relief.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Add a color relief layer</title>
    <meta property="og:description" content="Add a color relief layer." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<div id='map'></div>

<script>
    const map = window.map = new maplibregl.Map({
        container: 'map',
        zoom: 10,
        center: [11.45, 47.2],
        pitch: 0,
        renderWorldCopies: false,
        hash: true,
        style: {
            version: 8,
            sources: {
                terrainSource: {
                    type: 'raster-dem',
                    url: 'https://demotiles.maplibre.org/terrain-tiles/tiles.json',
                    tileSize: 256
                }
            },
            layers: [
                {
                    id: 'color-relief',
                    type: 'color-relief',
                    source: 'terrainSource',
                    paint: {
                        'color-relief-color': [
                            'interpolate',
                            ['linear'],
                            ['elevation'],
                            400, 'rgb(4, 0, 108)',
                            582.35, 'rgb(5, 1, 154)',
                            764.71, 'rgb(10, 21, 189)',
                            947.06, 'rgb(16, 44, 218)',
                            1129.41, 'rgb(24, 69, 240)',
                            1311.76, 'rgb(20, 112, 193)',
                            1494.12, 'rgb(39, 144, 116)',
                            1676.47, 'rgb(57, 169, 29)',
                            1858.82, 'rgb(111, 186, 5)',
                            2041.18, 'rgb(160, 201, 4)',
                            2223.53, 'rgb(205, 216, 2)',
                            2405.88, 'rgb(244, 221, 4)',
                            2588.24, 'rgb(251, 194, 14)',
                            2770.59, 'rgb(252, 163, 21)',
                            2952.94, 'rgb(253, 128, 20)',
                            3135.29, 'rgb(254, 85, 14)',
                            3317.65, 'rgb(243, 36, 13)',
                            3500, 'rgb(215, 5, 13)'
                        ]
                    }
                }
            ]
        },
        maxZoom: 18,
        maxPitch: 85
    });
</script>

</body>
</html>
```

// FILE ./line-across-180th-meridian.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Display line that crosses 180th meridian</title>
    <meta property="og:description" content="Draw a line across the 180th meridian using a GeoJSON source." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<div id="map"></div>
<script>
    const map = new maplibregl.Map({
        container: 'map',
        style:
            'https://api.maptiler.com/maps/streets/style.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL',
        center: [-41.62667, 26.11598],
        zoom: 0
    });

    map.on('load', () => {
        map.addLayer({
            'id': 'route',
            'type': 'line',
            'source': {
                'type': 'geojson',
                'data': {
                    'type': 'Feature',
                    'properties': {},
                    'geometry': createGeometry(false)
                }
            },
            'layout': {'line-cap': 'round'},
            'paint': {
                'line-color': '#007296',
                'line-width': 4
            }
        });

        map.addLayer({
            'id': 'route-label',
            'type': 'symbol',
            'source': 'route',
            'layout': {
                'symbol-placement': 'line-center',
                'text-field': 'Crosses the world'
            }
        });

        map.addLayer({
            'id': 'route-two',
            'type': 'line',
            'source': {
                'type': 'geojson',
                'data': {
                    'type': 'Feature',
                    'properties': {},
                    'geometry': createGeometry(true)
                }
            },
            'layout': {'line-cap': 'round'},
            'paint': {
                'line-color': '#F06317',
                'line-width': 4
            }
        });

        map.addLayer({
            'id': 'route-two-label',
            'type': 'symbol',
            'source': 'route-two',
            'layout': {
                'symbol-placement': 'line-center',
                'text-field': 'Crosses 180th meridian'
            }
        });

        function createGeometry(doesCrossAntimeridian) {
            const geometry = {
                'type': 'LineString',
                'coordinates': [
                    [-72.42187, -16.59408],
                    [140.27343, 35.67514]
                ]
            };

            // To draw a line across the 180th meridian,
            // if the longitude of the second point minus
            // the longitude of original (or previous) point is >= 180,
            // subtract 360 from the longitude of the second point.
            // If it is less than 180, add 360 to the second point.

            if (doesCrossAntimeridian) {
                const startLng = geometry.coordinates[0][0];
                const endLng = geometry.coordinates[1][0];

                if (endLng - startLng >= 180) {
                    geometry.coordinates[1][0] -= 360;
                } else if (endLng - startLng < 180) {
                    geometry.coordinates[1][0] += 360;
                }
            }

            return geometry;
        }
    });
</script>
</body>
</html>
```

// FILE ./disable-scroll-zoom.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Disable scroll zoom</title>
    <meta property="og:description" content="Prevent scroll from zooming a map." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<div id="map"></div>
<script>
    const map = new maplibregl.Map({
        container: 'map', // container id
        style:
            'https://api.maptiler.com/maps/streets/style.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL', //stylesheet location
        center: [-122.65, 45.52], // starting position
        zoom: 9 // starting zoom
    });

    // disable map zoom when using scroll
    map.scrollZoom.disable();
</script>
</body>
</html>
```

// FILE ./flyto.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Fly to a location</title>
    <meta property="og:description" content="Use flyTo to smoothly interpolate between locations." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<style>
    #fly {
        display: block;
        position: absolute;
        top: 20px;
        left: 50%;
        transform: translate(-50%);
        width: 50%;
        height: 40px;
        padding: 10px;
        border: none;
        border-radius: 3px;
        font-size: 12px;
        text-align: center;
        color: #fff;
        background: #ee8a65;
    }
</style>
<div id="map"></div>
<br />
<button id="fly">Fly</button>
<script>
    const map = new maplibregl.Map({
        container: 'map',
        style:
            'https://api.maptiler.com/maps/streets/style.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL',
        center: [-74.5, 40],
        zoom: 9
    });

    document.getElementById('fly').addEventListener('click', () => {
        // Fly to a random location by offsetting the point -74.50, 40
        // by up to 5 degrees.
        map.flyTo({
            center: [
                -74.5 + (Math.random() - 0.5) * 10,
                40 + (Math.random() - 0.5) * 10
            ],
            essential: true // this animation is considered essential with respect to prefers-reduced-motion
        });
    });
</script>
</body>
</html>
```

// FILE ./cluster.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Create and style clusters</title>
    <meta property="og:description" content="Use MapLibre GL JS' built-in functions to visualize points as clusters." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<div id="map"></div>

<script>
    const map = new maplibregl.Map({
        container: 'map',
        style: 'https://api.maptiler.com/maps/streets/style.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL',
        center: [-103.59179687498357, 40.66995747013945],
        zoom: 3
    });

    map.on('load', () => {
        // Add a new source from our GeoJSON data and
        // set the 'cluster' option to true. GL-JS will
        // add the point_count property to your source data.
        map.addSource('earthquakes', {
            type: 'geojson',
            // Point to GeoJSON data. This example visualizes all M1.0+ earthquakes
            // from 12/22/15 to 1/21/16 as logged by USGS' Earthquake hazards program.
            data: 'https://maplibre.org/maplibre-gl-js/docs/assets/earthquakes.geojson',
            cluster: true,
            clusterMaxZoom: 14, // Max zoom to cluster points on
            clusterRadius: 50 // Radius of each cluster when clustering points (defaults to 50)
        });

        map.addLayer({
            id: 'clusters',
            type: 'circle',
            source: 'earthquakes',
            filter: ['has', 'point_count'],
            paint: {
                // Use step expressions (https://maplibre.org/maplibre-style-spec/#expressions-step)
                // with three steps to implement three types of circles:
                //   * Blue, 20px circles when point count is less than 100
                //   * Yellow, 30px circles when point count is between 100 and 750
                //   * Pink, 40px circles when point count is greater than or equal to 750
                'circle-color': [
                    'step',
                    ['get', 'point_count'],
                    '#51bbd6',
                    100,
                    '#f1f075',
                    750,
                    '#f28cb1'
                ],
                'circle-radius': [
                    'step',
                    ['get', 'point_count'],
                    20,
                    100,
                    30,
                    750,
                    40
                ]
            }
        });

        map.addLayer({
            id: 'cluster-count',
            type: 'symbol',
            source: 'earthquakes',
            filter: ['has', 'point_count'],
            layout: {
                'text-field': '{point_count_abbreviated}',
                'text-font': ['DIN Offc Pro Medium', 'Arial Unicode MS Bold'],
                'text-size': 12
            }
        });

        map.addLayer({
            id: 'unclustered-point',
            type: 'circle',
            source: 'earthquakes',
            filter: ['!', ['has', 'point_count']],
            paint: {
                'circle-color': '#11b4da',
                'circle-radius': 4,
                'circle-stroke-width': 1,
                'circle-stroke-color': '#fff'
            }
        });

        // inspect a cluster on click
        map.on('click', 'clusters', async (e) => {
            const features = map.queryRenderedFeatures(e.point, {
                layers: ['clusters']
            });
            const clusterId = features[0].properties.cluster_id;
            const zoom = await map.getSource('earthquakes').getClusterExpansionZoom(clusterId);
            map.easeTo({
                center: features[0].geometry.coordinates,
                zoom
            });
        });

        // When a click event occurs on a feature in
        // the unclustered-point layer, open a popup at
        // the location of the feature, with
        // description HTML from its properties.
        map.on('click', 'unclustered-point', (e) => {
            const coordinates = e.features[0].geometry.coordinates.slice();
            const mag = e.features[0].properties.mag;
            let tsunami;

            if (e.features[0].properties.tsunami === 1) {
                tsunami = 'yes';
            } else {
                tsunami = 'no';
            }

            // Ensure that if the map is zoomed out such that
            // multiple copies of the feature are visible, the
            // popup appears over the copy being pointed to.
            while (Math.abs(e.lngLat.lng - coordinates[0]) > 180) {
                coordinates[0] += e.lngLat.lng > coordinates[0] ? 360 : -360;
            }

            new maplibregl.Popup()
                .setLngLat(coordinates)
                .setHTML(
                    `magnitude: ${mag}<br>Was there a tsunami?: ${tsunami}`
                )
                .addTo(map);
        });

        map.on('mouseenter', 'clusters', () => {
            map.getCanvas().style.cursor = 'pointer';
        });
        map.on('mouseleave', 'clusters', () => {
            map.getCanvas().style.cursor = '';
        });
    });
</script>
</body>
</html>
```

// FILE ./add-3d-model-with-terrain.html
```
<!DOCTYPE html>
<html lang="en">

<head>
    <title>Adding 3D models using three.js on terrain</title>
    <meta property="og:description" content="Use a custom style layer with three.js to add 3D models to a map with 3d terrain." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body {
            margin: 0;
            padding: 0;
        }

        html,
        body,
        #map {
            height: 100%;
        }
    </style>
    <script type="importmap">
        {
            "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.169.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.169.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
<div id="map"></div>

<script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        /**
         * Objective:
         * Given two known world-locations `model1Location` and `model2Location`,
         * place two three.js objects on those locations at the appropriate height of
         * the terrain.
         */

        async function main() {

            const map = new maplibregl.Map({
                container: 'map',
                center: [11.5257, 47.668],
                zoom: 16.27,
                pitch: 60,
                bearing: -28.5,
                canvasContextAttributes: {antialias: true},
                style: {
                    version: 8,
                    layers: [
                        {
                            id: 'baseColor', // Hides edges of terrain tiles, which have 'walls' going down to 0.
                            type: 'background',
                            paint: {
                                'background-color': '#fff',
                                'background-opacity': 1.0,
                            },
                        }, {
                            id: 'hills',
                            type: 'hillshade',
                            source: 'hillshadeSource',
                            layout: {visibility: 'visible'},
                            paint: {'hillshade-shadow-color': '#473B24'}
                        }
                    ],
                    terrain: {
                        source: 'terrainSource',
                        exaggeration: 1,
                    },
                    sources: {
                        terrainSource: {
                            type: 'raster-dem',
                            url: 'https://demotiles.maplibre.org/terrain-tiles/tiles.json',
                            tileSize: 256
                        },
                        hillshadeSource: {
                            type: 'raster-dem',
                            url: 'https://demotiles.maplibre.org/terrain-tiles/tiles.json',
                            tileSize: 256
                        }
                    },
                }
            });

            /*
            * Helper function used to get threejs-scene-coordinates from mercator coordinates.
            * This is just a quick and dirty solution - it won't work if points are far away from each other
            * because a meter near the north-pole covers more mercator-units
            * than a meter near the equator.
            */
            function calculateDistanceMercatorToMeters(from, to) {
                const mercatorPerMeter = from.meterInMercatorCoordinateUnits();
                // mercator x: 0=west, 1=east
                const dEast = to.x - from.x;
                const dEastMeter = dEast / mercatorPerMeter;
                // mercator y: 0=north, 1=south
                const dNorth = from.y - to.y;
                const dNorthMeter = dNorth / mercatorPerMeter;
                return {dEastMeter, dNorthMeter};
            }

            async function loadModel() {
                const loader = new GLTFLoader();
                const gltf = await loader.loadAsync('https://maplibre.org/maplibre-gl-js/docs/assets/34M_17/34M_17.gltf');
                const model = gltf.scene;
                return model;
            }

            // Known locations. We'll infer the elevation of those locations once terrain is loaded.
            const sceneOrigin = new maplibregl.LngLat(11.5255, 47.6677);
            const model1Location = new maplibregl.LngLat(11.527, 47.6678);
            const model2Location = new maplibregl.LngLat(11.5249, 47.6676);

            // Configuration of the custom layer for a 3D model, implementing `CustomLayerInterface`.
            const customLayer = {
                id: '3d-model',
                type: 'custom',
                renderingMode: '3d',

                onAdd(map, gl) {
                    /**
                     * Setting up three.js scene.
                     * We're placing model1 and model2 in such a way that the whole scene fits over the terrain.
                     */

                    this.camera = new THREE.Camera();
                    this.scene = new THREE.Scene();
                    // In threejs, y points up - we're rotating the scene such that it's y points along maplibre's up.
                    this.scene.rotateX(Math.PI / 2);
                    // In threejs, z points toward the viewer - mirroring it such that z points along maplibre's north.
                    this.scene.scale.multiply(new THREE.Vector3(1, 1, -1));
                    // We now have a scene with (x=east, y=up, z=north)

                    const light = new THREE.DirectionalLight(0xffffff);
                    // Making it just before noon - light coming from south-east.
                    light.position.set(50, 70, -30).normalize();
                    this.scene.add(light);

                    // Axes helper to show how threejs scene is oriented.
                    const axesHelper = new THREE.AxesHelper(60);
                    this.scene.add(axesHelper);

                    // Getting model elevations in meters above sea level
                    const sceneElevation = map.queryTerrainElevation(sceneOrigin) || 0;
                    const model1Elevation = map.queryTerrainElevation(model1Location) || 0;
                    const model2Elevation = map.queryTerrainElevation(model2Location) || 0;
                    const model1up = model1Elevation - sceneElevation;
                    const model2up = model2Elevation - sceneElevation;

                    // Getting model x and y (in meters) relative to scene origin.
                    const sceneOriginMercator = maplibregl.MercatorCoordinate.fromLngLat(sceneOrigin);
                    const model1Mercator = maplibregl.MercatorCoordinate.fromLngLat(model1Location);
                    const model2Mercator = maplibregl.MercatorCoordinate.fromLngLat(model2Location);
                    const {dEastMeter: model1east, dNorthMeter: model1north} = calculateDistanceMercatorToMeters(sceneOriginMercator, model1Mercator);
                    const {dEastMeter: model2east, dNorthMeter: model2north} = calculateDistanceMercatorToMeters(sceneOriginMercator, model2Mercator);

                    model1.position.set(model1east, model1up, model1north);
                    model2.position.set(model2east, model2up, model2north);

                    this.scene.add(model1);
                    this.scene.add(model2);

                    // Use the MapLibre GL JS map canvas for three.js.
                    this.renderer = new THREE.WebGLRenderer({
                        canvas: map.getCanvas(),
                        context: gl,
                        antialias: true
                    });

                    this.renderer.autoClear = false;
                },

                render(gl, args) {
                    const offsetFromCenterElevation = map.queryTerrainElevation(sceneOrigin) || 0;
                    const sceneOriginMercator = maplibregl.MercatorCoordinate.fromLngLat(sceneOrigin, offsetFromCenterElevation);

                    const sceneTransform = {
                        translateX: sceneOriginMercator.x,
                        translateY: sceneOriginMercator.y,
                        translateZ: sceneOriginMercator.z,
                        scale: sceneOriginMercator.meterInMercatorCoordinateUnits()
                    };

                    const m = new THREE.Matrix4().fromArray(args.defaultProjectionData.mainMatrix);
                    const l = new THREE.Matrix4()
                        .makeTranslation(sceneTransform.translateX, sceneTransform.translateY, sceneTransform.translateZ)
                        .scale(new THREE.Vector3(sceneTransform.scale, -sceneTransform.scale, sceneTransform.scale));

                    this.camera.projectionMatrix = m.multiply(l);
                    this.renderer.resetState();
                    this.renderer.render(this.scene, this.camera);
                    map.triggerRepaint();
                }
            };

            const results = await Promise.all([map.once('load'), loadModel()]);
            const model1 = results[1];
            const model2 = model1.clone();

            map.addLayer(customLayer);
        }

        main();
    </script>
</body>

</html>
```

// FILE ./drag-a-point.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Create a draggable point</title>
    <meta property="og:description" content="Drag the point to a new location on a map and populate its coordinates in a display." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<style>
    .coordinates {
        background: rgba(0, 0, 0, 0.5);
        color: #fff;
        position: absolute;
        bottom: 40px;
        left: 10px;
        padding: 5px 10px;
        margin: 0;
        font-size: 11px;
        line-height: 18px;
        border-radius: 3px;
        display: none;
    }
</style>

<div id="map"></div>
<pre id="coordinates" class="coordinates"></pre>

<script>
    const coordinates = document.getElementById('coordinates');
    const map = new maplibregl.Map({
        container: 'map',
        style:
            'https://api.maptiler.com/maps/streets/style.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL',
        center: [0, 0],
        zoom: 2
    });

    const canvas = map.getCanvasContainer();

    const geojson = {
        'type': 'FeatureCollection',
        'features': [
            {
                'type': 'Feature',
                'geometry': {
                    'type': 'Point',
                    'coordinates': [0, 0]
                }
            }
        ]
    };

    function onMove(e) {
        const coords = e.lngLat;

        // Set a UI indicator for dragging.
        canvas.style.cursor = 'grabbing';

        // Update the Point feature in `geojson` coordinates
        // and call setData to the source layer `point` on it.
        geojson.features[0].geometry.coordinates = [coords.lng, coords.lat];
        map.getSource('point').setData(geojson);
    }

    function onUp(e) {
        const coords = e.lngLat;

        // Print the coordinates of where the point had
        // finished being dragged to on the map.
        coordinates.style.display = 'block';
        coordinates.innerHTML =
            `Longitude: ${coords.lng}<br />Latitude: ${coords.lat}`;
        canvas.style.cursor = '';

        // Unbind mouse/touch events
        map.off('mousemove', onMove);
        map.off('touchmove', onMove);
    }

    map.on('load', () => {
        // Add a single point to the map
        map.addSource('point', {
            'type': 'geojson',
            'data': geojson
        });

        map.addLayer({
            'id': 'point',
            'type': 'circle',
            'source': 'point',
            'paint': {
                'circle-radius': 10,
                'circle-color': '#3887be'
            }
        });

        // When the cursor enters a feature in the point layer, prepare for dragging.
        map.on('mouseenter', 'point', () => {
            map.setPaintProperty('point', 'circle-color', '#3bb2d0');
            canvas.style.cursor = 'move';
        });

        map.on('mouseleave', 'point', () => {
            map.setPaintProperty('point', 'circle-color', '#3887be');
            canvas.style.cursor = '';
        });

        map.on('mousedown', 'point', (e) => {
            // Prevent the default map drag behavior.
            e.preventDefault();

            canvas.style.cursor = 'grab';

            map.on('mousemove', onMove);
            map.once('mouseup', onUp);
        });

        map.on('touchstart', 'point', (e) => {
            if (e.points.length !== 1) return;

            // Prevent the default map drag behavior.
            e.preventDefault();

            map.on('touchmove', onMove);
            map.once('touchend', onUp);
        });
    });
</script>
</body>
</html>
```

// FILE ./hover-styles.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Create a hover effect</title>
    <meta property="og:description" content="Use events and feature states to create a per feature hover effect." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<div id="map"></div>
<script>
    const map = new maplibregl.Map({
        container: 'map',
        style:
            'https://api.maptiler.com/maps/streets/style.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL',
        center: [-100.486052, 37.830348],
        zoom: 2
    });
    let hoveredStateId = null;

    map.on('load', () => {
        map.addSource('states', {
            'type': 'geojson',
            'data':
                'https://maplibre.org/maplibre-gl-js/docs/assets/us_states.geojson'
        });

        // The feature-state dependent fill-opacity expression will render the hover effect
        // when a feature's hover state is set to true.
        map.addLayer({
            'id': 'state-fills',
            'type': 'fill',
            'source': 'states',
            'layout': {},
            'paint': {
                'fill-color': '#627BC1',
                'fill-opacity': [
                    'case',
                    ['boolean', ['feature-state', 'hover'], false],
                    1,
                    0.5
                ]
            }
        });

        map.addLayer({
            'id': 'state-borders',
            'type': 'line',
            'source': 'states',
            'layout': {},
            'paint': {
                'line-color': '#627BC1',
                'line-width': 2
            }
        });

        // When the user moves their mouse over the state-fill layer, we'll update the
        // feature state for the feature under the mouse.
        map.on('mousemove', 'state-fills', (e) => {
            if (e.features.length > 0) {
                if (hoveredStateId) {
                    map.setFeatureState(
                        {source: 'states', id: hoveredStateId},
                        {hover: false}
                    );
                }
                hoveredStateId = e.features[0].id;
                map.setFeatureState(
                    {source: 'states', id: hoveredStateId},
                    {hover: true}
                );
            }
        });

        // When the mouse leaves the state-fill layer, update the feature state of the
        // previously hovered feature.
        map.on('mouseleave', 'state-fills', () => {
            if (hoveredStateId) {
                map.setFeatureState(
                    {source: 'states', id: hoveredStateId},
                    {hover: false}
                );
            }
            hoveredStateId = null;
        });
    });
</script>
</body>
</html>
```

// FILE ./add-image-missing-generated.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Generate and add a missing icon to the map</title>
    <meta property="og:description" content="Dynamically generate a missing icon at runtime and add it to the map." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<div id="map"></div>

<script>
    const map = new maplibregl.Map({
        container: 'map',
        style:
            'https://api.maptiler.com/maps/streets/style.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL'
    });

    map.on('styleimagemissing', (e) => {
        const id = e.id; // id of the missing image

        // check if this missing icon is one this function can generate
        const prefix = 'square-rgb-';
        if (id.indexOf(prefix) !== 0) return;

        // extract the color from the id
        const rgb = id.replace(prefix, '').split(',').map(Number);

        const width = 64; // The image will be 64 pixels square
        const bytesPerPixel = 4; // Each pixel is represented by 4 bytes: red, green, blue, and alpha.
        const data = new Uint8Array(width * width * bytesPerPixel);

        for (let x = 0; x < width; x++) {
            for (let y = 0; y < width; y++) {
                const offset = (y * width + x) * bytesPerPixel;
                data[offset + 0] = rgb[0]; // red
                data[offset + 1] = rgb[1]; // green
                data[offset + 2] = rgb[2]; // blue
                data[offset + 3] = 255; // alpha
            }
        }

        map.addImage(id, {width, height: width, data});
    });

    map.on('load', () => {
        map.addSource('points', {
            'type': 'geojson',
            'data': {
                'type': 'FeatureCollection',
                'features': [
                    {
                        'type': 'Feature',
                        'geometry': {
                            'type': 'Point',
                            'coordinates': [0, 0]
                        },
                        'properties': {
                            'color': '255,0,0'
                        }
                    },
                    {
                        'type': 'Feature',
                        'geometry': {
                            'type': 'Point',
                            'coordinates': [50, 0]
                        },
                        'properties': {
                            'color': '255,209,28'
                        }
                    },
                    {
                        'type': 'Feature',
                        'geometry': {
                            'type': 'Point',
                            'coordinates': [-50, 0]
                        },
                        'properties': {
                            'color': '242,127,32'
                        }
                    }
                ]
            }
        });

        map.addLayer({
            'id': 'points',
            'type': 'symbol',
            'source': 'points',
            'layout': {
                'icon-image': ['concat', 'square-rgb-', ['get', 'color']]
            }
        });
    });
</script>
</body>
</html>
```

// FILE ./globe-zoom-planet-size-function.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Zoom and planet size relation on globe</title>
    <meta property="og:description" content="Explanation of zoom and planet size relation under globe projection and how to account for it when changing the map center and zoom by some delta." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 99%; }
    </style>
</head>
<body>
<style>
    #fly {
        display: block;
        position: absolute;
        top: 20px;
        left: 50%;
        transform: translate(-50%);
        width: 50%;
        height: 40px;
        padding: 10px;
        border: none;
        border-radius: 3px;
        font-size: 12px;
        text-align: center;
        color: #fff;
        background: #ee8a65;
    }
</style>
<div id="map"></div>
<br />
<button id="fly">Go to pole or equator</button>
<script>
    const map = new maplibregl.Map({
        container: 'map',
        style: 'https://demotiles.maplibre.org/style.json',
        center: [0, 0],
        zoom: 2,
    });

    map.on('style.load', () => {
        map.setProjection({
            type: 'globe', // Set projection to globe
        });
    });

    // To stay consistent with web mercator maps, globe is automatically enlarged when map center is nearing the poles.
    // This keeps the map center visually similar to a mercator map with the same x,y and zoom.
    // However, sometimes we want to negate this effect and keep the globe size consistent even when changing latitudes.
    // This function computes what we need to add the the target zoom level when changing latitude.
    function getZoomAdjustment(oldLatitude, newLatitude) {
        return Math.log2(Math.cos(newLatitude / 180 * Math.PI) / Math.cos(oldLatitude / 180 * Math.PI));
    }

    // Switch back and forth between zooming in and out.
    let zoomIn = false;
    const zoomDelta = 1.5;

    document.getElementById('fly').addEventListener('click', () => {
        // Fly to a random location by offsetting the point -74.50, 40
        // by up to 5 degrees.
        const center = [
            map.getCenter().lng,
            zoomIn ? 0 : 80,
        ];
        const mapZoom = map.getZoom();
        const delta = (zoomIn ? zoomDelta : -zoomDelta);
        // We want to change the map's globe size by some delta and change the center latitude at the same time,
        // thus we need to compensate for the globe enlarging effect described earlier.
        const zoom = map.getZoom() + delta + getZoomAdjustment(map.getCenter().lat, center[1]);
        map.flyTo({
            center,
            zoom,
            essential: true // this animation is considered essential with respect to prefers-reduced-motion
        });
        zoomIn = !zoomIn;
    });
</script>
</body>
</html>
```

// FILE ./sync-move.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Sync movement of multiple maps</title>
    <meta property="og:description" content="Synchronize MapLibre GL JS maps with the sync-move plugin." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <script src="https://unpkg.com/@mapbox/mapbox-gl-sync-move@0.3.1"></script>

    <style>
        body { margin: 0; padding: 0; }
        html, body { height: 100%; }
        #map1, #map2, #map3 { height: 100%; width: 100%; }
        .maps {
            display: flex;
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <div class="maps">
    <div id="map1"></div>
    <div id="map2"></div>
    <div id="map3"></div>
    </div>
<script>
    const map1 = new maplibregl.Map({
        container: 'map1',
        style: 'https://demotiles.maplibre.org/style.json',
        center: [0, 0],
        zoom: 1,
        maplibreLogo: true
    });
    const map2 = new maplibregl.Map({
        container: 'map2',
        style: 'https://basemaps.cartocdn.com/gl/positron-gl-style/style.json',
        center: [0, 0],
        zoom: 1,
        maplibreLogo: true
    });
    const map3 = new maplibregl.Map({
        container: 'map3',
        style: 'https://basemaps.cartocdn.com/gl/dark-matter-gl-style/style.json',
        center: [0, 0],
        zoom: 1,
        maplibreLogo: true
    });

    syncMaps(map1, map2, map3);
</script>
</body>
</html>
```

// FILE ./mapbox-gl-draw.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Draw polygon with mapbox-gl-draw</title>
    <meta property="og:description" content="Use mapbox-gl-draw to draw a polygon and Turf.js to calculate its area in square meters." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<style>
    .calculation-box {
        height: 75px;
        width: 150px;
        position: absolute;
        bottom: 40px;
        left: 10px;
        background-color: rgba(255, 255, 255, 0.9);
        padding: 15px;
        text-align: center;
    }

    p {
        font-family: 'Open Sans';
        margin: 0;
        font-size: 13px;
    }
</style>
    <script src="https://www.unpkg.com/@mapbox/mapbox-gl-draw@1.5.0/dist/mapbox-gl-draw.js"></script>
    <link
        rel="stylesheet"
        href="https://www.unpkg.com/@mapbox/mapbox-gl-draw@1.5.0/dist/mapbox-gl-draw.css"
    />
    <div id="map"></div>
    <div class="calculation-box">
        <p>Draw a polygon using the draw tools.</p>
        <div id="calculated-area"></div>
    </div>

    <script type="module">


    import * as turf from 'https://esm.sh/@turf/turf@7.1.0';

    MapboxDraw.constants.classes.CANVAS  = 'maplibregl-canvas';
    MapboxDraw.constants.classes.CONTROL_BASE  = 'maplibregl-ctrl';
    MapboxDraw.constants.classes.CONTROL_PREFIX = 'maplibregl-ctrl-';
    MapboxDraw.constants.classes.CONTROL_GROUP = 'maplibregl-ctrl-group';
    MapboxDraw.constants.classes.ATTRIBUTION = 'maplibregl-ctrl-attrib';

    const map = new maplibregl.Map({
        container: 'map', // container id
        style:
            'https://api.maptiler.com/maps/streets/style.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL', //hosted style id
        center: [-91.874, 42.76], // starting position
        zoom: 12 // starting zoom
    });

    const draw = new MapboxDraw({
        displayControlsDefault: false,
        controls: {
            polygon: true,
            trash: true
        }
    });
    map.addControl(draw);

    map.on('draw.create', updateArea);
    map.on('draw.delete', updateArea);
    map.on('draw.update', updateArea);

    function updateArea(e) {
        const data = draw.getAll();
        const answer = document.getElementById('calculated-area');
        if (data.features.length > 0) {
            const area = turf.area(data);
            // restrict to area to 2 decimal points
            const roundedArea = Math.round(area * 100) / 100;
            answer.innerHTML =
                `<p><strong>${
                    roundedArea
                }</strong></p><p>square meters</p>`;
        } else {
            answer.innerHTML = '';
            if (e.type !== 'draw.delete')
                alert('Use the draw tools to draw a polygon!');
        }
    }
</script>
</body>
</html>
```

// FILE ./center-point.html
```
<!DOCTYPE html>
<html lang="en">
<head>
  <title>Set center point above ground</title>
  <meta property="og:description" content="Set the center point above ground level." />
  <meta charset='utf-8'>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
  <script src='../../dist/maplibre-gl-dev.js'></script>
  <style>
      body { margin: 0; padding: 0; }
      html, body, #map { height: 100%; }
  </style>
</head>
<body>
<div id="map"></div>
<script>
  const MAPTILER_KEY = 'get_your_own_OpIi9ZULNHzrESv6T2vL';
  const map = new maplibregl.Map({
      style: {
        version: 8,
        sources: {
            openmaptiles: {
                url: `https://api.maptiler.com/tiles/v3/tiles.json?key=${MAPTILER_KEY}`,
                type: 'vector',
            }
        },
        layers: [
            {
              'id': '3d-buildings',
              'source': 'openmaptiles',
              'source-layer': 'building',
              'type': 'fill-extrusion',
              'minzoom': 13,
              'filter': ['!=', ['get', 'hide_3d'], true],
              'paint': {
                  'fill-extrusion-color': [
                      'interpolate',
                      ['linear'],
                      ['get', 'render_height'], 0, 'lightgray', 200, 'royalblue', 400, 'lightblue'
                  ],
                  'fill-extrusion-height': [
                      'interpolate',
                      ['linear'],
                      ['zoom'],
                      13,
                      0,
                      14,
                      ['get', 'render_height']
                  ],
                  'fill-extrusion-base': ['case',
                      ['>=', ['get', 'zoom'], 16],
                      ['get', 'render_min_height'], 0
                  ]
              }
          }
        ]
      },
      center: [-74.01318, 40.713],
      minZoom: 13,
      zoom: 15.5,
      pitch: 85,
      bearing: -17.6,
      container: 'map',
      canvasContextAttributes: {antialias: true},
      centerClampedToGround: false,
      elevation: 541,
      maxPitch: 105
  });
</script>
</body>
</html>
```

// FILE ./hillshade-multidirectional.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Add a multidirectional hillshade layer</title>
    <meta property="og:description" content="Add a hillshade layer with multiple illumination sources." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<div id='map'></div>

<script>
    const map = window.map = new maplibregl.Map({
        container: 'map',
        zoom: 10,
        center: [11.491, 47.274],
        pitch: 0,
        renderWorldCopies: false,
        hash: true,
        style: {
            version: 8,
            sources: {
                hillshadeSource: {
                    type: 'raster-dem',
                    url: 'https://demotiles.maplibre.org/terrain-tiles/tiles.json',
                    tileSize: 256
                }
            },
            layers: [
                {
                    id: 'hillshade',
                    type: 'hillshade',
                    source: 'hillshadeSource',
                    paint: {
                        'hillshade-method': 'multidirectional',
                        'hillshade-highlight-color': ['#FF4000', '#FFFF00', '#40ff00', '#00FF80'],
                        'hillshade-shadow-color': ['#00bfff', '#0000ff', '#bf00ff', '#FF0080'],
                        'hillshade-illumination-direction': [270, 315, 0, 45],
                        'hillshade-illumination-altitude': [30, 30, 30, 30]
                    }
                }
            ]
        },
        maxZoom: 18,
        maxPitch: 85
    });
</script>

</body>
</html>
```

// FILE ./scroll-fly-to.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Fly to a location based on scroll position</title>
    <meta property="og:description" content="Scroll down through the story and the map will fly to the chapter's location." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<style>
    #map {
        position: fixed;
        width: 50%;
    }
    #features {
        width: 50%;
        margin-left: 50%;
        font-family: sans-serif;
        overflow-y: scroll;
        background-color: #fafafa;
    }
    section {
        padding: 25px 50px;
        line-height: 25px;
        border-bottom: 1px solid #ddd;
        opacity: 0.25;
        font-size: 13px;
    }
    section.active {
        opacity: 1;
    }
    section:last-child {
        border-bottom: none;
        margin-bottom: 200px;
    }
</style>

<div id="map"></div>
<div id="features">
    <section id="baker" class="active">
        <h3>221b Baker St.</h3>
        <p>
            November 1895. London is shrouded in fog and Sherlock Holmes and
            Watson pass time restlessly awaiting a new case. "The London
            criminal is certainly a dull fellow," Sherlock bemoans. "There have
            been numerous petty thefts," Watson offers in response. Just then a
            telegram arrives from Sherlock's brother Mycroft with a mysterious
            case.
        </p>
    </section>
    <section id="aldgate">
        <h3>Aldgate Station</h3>
        <p>
            Arthur Cadogan West was found dead, head crushed in on train tracks
            at Aldgate Station at 6AM Tuesday morning. West worked at Woolwich
            Arsenal on the Bruce-Partington submarine, a secret military
            project. Plans for the submarine had been stolen and seven of the
            ten missing papers were found in West's possession. Mycroft implores
            Sherlock to take the case and recover the three missing papers.
        </p>
    </section>
    <section id="london-bridge">
        <h3>London Bridge</h3>
        <p>
            Holmes and Watson's investigations take them across London. Sherlock
            deduces that West was murdered elsewhere, then moved to Aldgate
            Station to create the illusion that he was crushed on the tracks by
            a train. On their way to Woolwich Sherlock dispatches a telegram to
            Mycroft at London Bridge: "Send list of all foreign spies known to
            be in England, with full address."
        </p>
    </section>
    <section id="woolwich">
        <h3>Woolwich Arsenal</h3>
        <p>
            While investigating at Woolwich Arsenal Sherlock learns that West
            did not have the three keys&mdash;door, office, and
            safe&mdash;necessary to steal the papers. The train station clerk
            mentions seeing an agitated West boarding the 8:15 train to London
            Bridge. Sherlock suspects West of following someone who had access
            to the Woolwich chief's keyring with all three keys.
        </p>
    </section>
    <section id="gloucester">
        <h3>Gloucester Road</h3>
        <p>
            Mycroft responds to Sherlock's telegram and mentions several spies.
            Hugo Oberstein of 13 Caulfield Gardens catches Sherlock's eye. He
            heads to the nearby Gloucester Road station to investigate and
            learns that the windows of Caulfield Gardens open over rail tracks
            where trains stop frequently.
        </p>
    </section>
    <section id="caulfield-gardens">
        <h3>13 Caulfield Gardens</h3>
        <p>
            Holmes deduces that the murderer placed West atop a stopped train at
            Caulfield Gardens. The train traveled to Aldgate Station before
            West's body finally toppled off. Backtracking to the criminal's
            apartment, Holmes finds a series of classified ads from
            <em>The Daily Telegraph</em> stashed away. All are under the name
            Pierrot: "Monday night after nine. Two taps. Only ourselves. Do not
            be so suspicious. Payment in hard cash when goods delivered."
        </p>
    </section>
    <section id="telegraph">
        <h3>The Daily Telegraph</h3>
        <p>
            Holmes and Watson head to The Daily Telegraph and place an ad to
            draw out the criminal. It reads: "To-night. Same hour. Same place.
            Two taps. Most vitally important. Your own safety at stake.
            Pierrot." The trap works and Holmes catches the criminal: Colonel
            Valentine Walter, the brother of Woolwich Arsenal's chief. He
            confesses to working for Hugo Oberstein to obtain the submarine
            plans in order to pay off his debts.
        </p>
    </section>
    <section id="charing-cross">
        <h3>Charing Cross Hotel</h3>
        <p>
            Walter writes to Oberstein and convinces him to meet in the smoking
            room of the Charing Cross Hotel where he promises additional plans
            for the submarine in exchange for money. The plan works and Holmes
            and Watson catch both criminals.
        </p>
        <small id="citation">
            Adapted from
            <a href="https://www.gutenberg.org/files/2346/2346-h/2346-h.htm"
                >Project Gutenberg</a
            >
        </small>
    </section>
</div>
<script>
    const map = new maplibregl.Map({
        container: 'map',
        style:
            'https://api.maptiler.com/maps/streets/style.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL',
        center: [-0.15591514, 51.51830379],
        zoom: 15.5,
        bearing: 27,
        pitch: 45
    });

    const chapters = {
        'baker': {
            bearing: 27,
            center: [-0.15591514, 51.51830379],
            zoom: 15.5,
            pitch: 20
        },
        'aldgate': {
            duration: 6000,
            center: [-0.07571203, 51.51424049],
            bearing: 150,
            zoom: 15,
            pitch: 0
        },
        'london-bridge': {
            bearing: 90,
            center: [-0.08533793, 51.50438536],
            zoom: 13,
            speed: 0.6,
            pitch: 40
        },
        'woolwich': {
            bearing: 90,
            center: [0.05991101, 51.48752939],
            zoom: 12.3
        },
        'gloucester': {
            bearing: 45,
            center: [-0.18335806, 51.49439521],
            zoom: 15.3,
            pitch: 20,
            speed: 0.5
        },
        'caulfield-gardens': {
            bearing: 180,
            center: [-0.19684993, 51.5033856],
            zoom: 12.3
        },
        'telegraph': {
            bearing: 90,
            center: [-0.10669358, 51.51433123],
            zoom: 17.3,
            pitch: 40
        },
        'charing-cross': {
            bearing: 90,
            center: [-0.12416858, 51.50779757],
            zoom: 14.3,
            pitch: 20
        }
    };

    // On every scroll event, check which element is on screen
    window.onscroll = function () {
        const chapterNames = Object.keys(chapters);
        for (let i = 0; i < chapterNames.length; i++) {
            const chapterName = chapterNames[i];
            if (isElementOnScreen(chapterName)) {
                setActiveChapter(chapterName);
                break;
            }
        }
    };

    let activeChapterName = 'baker';
    function setActiveChapter(chapterName) {
        if (chapterName === activeChapterName) return;

        map.flyTo(chapters[chapterName]);

        document.getElementById(chapterName).setAttribute('class', 'active');
        document.getElementById(activeChapterName).setAttribute('class', '');

        activeChapterName = chapterName;
    }

    function isElementOnScreen(id) {
        const element = document.getElementById(id);
        const bounds = element.getBoundingClientRect();
        return bounds.top < window.innerHeight && bounds.bottom > 0;
    }
</script>
</body>
</html>
```

// FILE ./3d-buildings.html
```
<!DOCTYPE html>
<html lang="en">
<head>
  <title>Display buildings in 3D</title>
  <meta property="og:description" content="Use extrusions to display buildings' height in 3D." />
  <meta charset='utf-8'>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
  <script src='../../dist/maplibre-gl-dev.js'></script>
  <style>
      body { margin: 0; padding: 0; }
      html, body, #map { height: 100%; }
  </style>
</head>
<body>
<div id="map"></div>
<script>
  const MAPTILER_KEY = 'get_your_own_OpIi9ZULNHzrESv6T2vL';
  const map = new maplibregl.Map({
      style: `https://api.maptiler.com/maps/basic-v2/style.json?key=${MAPTILER_KEY}`,
      center: [-74.0066, 40.7135],
      zoom: 15.5,
      pitch: 45,
      bearing: -17.6,
      container: 'map',
      canvasContextAttributes: {antialias: true}
  });
  
  // The 'building' layer in the streets vector source contains building-height
  // data from OpenStreetMap.
  map.on('load', () => {
      // Insert the layer beneath any symbol layer.
      const layers = map.getStyle().layers;

      let labelLayerId;
      for (let i = 0; i < layers.length; i++) {
          if (layers[i].type === 'symbol' && layers[i].layout['text-field']) {
              labelLayerId = layers[i].id;
              break;
          }
      }

      map.addSource('openmaptiles', {
          url: `https://api.maptiler.com/tiles/v3/tiles.json?key=${MAPTILER_KEY}`,
          type: 'vector',
      });

      map.addLayer(
          {
              'id': '3d-buildings',
              'source': 'openmaptiles',
              'source-layer': 'building',
              'type': 'fill-extrusion',
              'minzoom': 15,
              'filter': ['!=', ['get', 'hide_3d'], true],
              'paint': {
                  'fill-extrusion-color': [
                      'interpolate',
                      ['linear'],
                      ['get', 'render_height'], 0, 'lightgray', 200, 'royalblue', 400, 'lightblue'
                  ],
                  'fill-extrusion-height': [
                      'interpolate',
                      ['linear'],
                      ['zoom'],
                      15,
                      0,
                      16,
                      ['get', 'render_height']
                  ],
                  'fill-extrusion-base': ['case',
                      ['>=', ['get', 'zoom'], 16],
                      ['get', 'render_min_height'], 0
                  ]
              }
          },
          labelLayerId
      );
  });
</script>
</body>
</html>
```

// FILE ./add-image-stretchable.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Add a stretchable image to the map</title>
    <meta property="og:description" content="Use a stretchable image as a background for text." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<div id="map"></div>

<script>
    const map = new maplibregl.Map({
        container: 'map',
        style:
            'https://api.maptiler.com/maps/streets/style.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL',
        zoom: 0.1
    });

    const images = {
        'popup': 'https://maplibre.org/maplibre-gl-js/docs/assets/popup.png',
        'popup-debug':
            'https://maplibre.org/maplibre-gl-js/docs/assets/popup_debug.png'
    };

    map.on('load', async () => {
        const debugPopup = await map.loadImage(images['popup-debug']);
        const popup = await map.loadImage(images['popup']);
        map.addImage('popup-debug', debugPopup.data, {
            // The two (blue) columns of pixels that can be stretched horizontally:
            //   - the pixels between x: 25 and x: 55 can be stretched
            //   - the pixels between x: 85 and x: 115 can be stretched.
            stretchX: [
                [25, 55],
                [85, 115]
            ],
            // The one (red) row of pixels that can be stretched vertically:
            //   - the pixels between y: 25 and y: 100 can be stretched
            stretchY: [[25, 100]],
            // This part of the image that can contain text ([x1, y1, x2, y2]):
            content: [25, 25, 115, 100],
            // This is a high-dpi image:
            pixelRatio: 2
        });
        map.addImage('popup', popup.data, {
            stretchX: [
                [25, 55],
                [85, 115]
            ],
            stretchY: [[25, 100]],
            content: [25, 25, 115, 100],
            pixelRatio: 2
        });

        map.addSource('points', {
            'type': 'geojson',
            'data': {
                'type': 'FeatureCollection',
                'features': [
                    {
                        'type': 'Feature',
                        'geometry': {
                            'type': 'Point',
                            'coordinates': [40, -30]
                        },
                        'properties': {
                            'image-name': 'popup-debug',
                            'name': 'Line 1
Line 2
Line 3'
                        }
                    },
                    {
                        'type': 'Feature',
                        'geometry': {
                            'type': 'Point',
                            'coordinates': [40, 30]
                        },
                        'properties': {
                            'image-name': 'popup',
                            'name': 'Line 1
Line 2
Line 3'
                        }
                    },
                    {
                        'type': 'Feature',
                        'geometry': {
                            'type': 'Point',
                            'coordinates': [-40, -30]
                        },
                        'properties': {
                            'image-name': 'popup-debug',
                            'name': 'One longer line'
                        }
                    },
                    {
                        'type': 'Feature',
                        'geometry': {
                            'type': 'Point',
                            'coordinates': [-40, 30]
                        },
                        'properties': {
                            'image-name': 'popup',
                            'name': 'One longer line'
                        }
                    }
                ]
            }
        });
        map.addLayer({
            'id': 'points',
            'type': 'symbol',
            'source': 'points',
            'layout': {
                'text-field': ['get', 'name'],
                'icon-text-fit': 'both',
                'icon-image': ['get', 'image-name'],
                'icon-overlap': 'always',
                'text-overlap': 'always'
            }
        });

        // the original, non-stretched image for comparison
        map.addSource('original', {
            'type': 'geojson',
            'data': {
                'type': 'FeatureCollection',
                'features': [
                    {
                        'type': 'Feature',
                        'geometry': {
                            'type': 'Point',
                            'coordinates': [0, -70]
                        }
                    }
                ]
            }
        });
        map.addLayer({
            'id': 'original',
            'type': 'symbol',
            'source': 'original',
            'layout': {
                'text-field': 'non-stretched image',
                'icon-image': 'popup-debug',
                'icon-overlap': 'always',
                'text-overlap': 'always'
            }
        });
    });
</script>
</body>
</html>
```

// FILE ./add-3d-model-threejs-with-shadow.html
```
<!DOCTYPE html>
<html lang="en">

<head>
    <title>Add a 3D model with shadow using three.js</title>
    <meta property="og:description"
        content="Use a custom style layer with three.js to add a 3D model with shadow to the map." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body {
            margin: 0;
            padding: 0;
        }

        html,
        body,
        #map {
            height: 100%;
        }
    </style>
    <script type="importmap">
        {
            "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.169.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.169.0/examples/jsm/"
            }
        }
    </script>
</head>

<body>
    <div id="map"></div>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        const map = new maplibregl.Map({
            container: 'map',
            style:
                'https://api.maptiler.com/maps/basic/style.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL',
            zoom: 18,
            center: [148.9819, -35.3981],
            pitch: 60,
            canvasContextAttributes: {antialias: true}
        });

        const modelOrigin = [148.9819, -35.39847];
        const modelAltitude = 0;
        const modelRotate = [Math.PI / 2, 0, 0];

        const modelAsMercatorCoordinate = maplibregl.MercatorCoordinate.fromLngLat(
            modelOrigin,
            modelAltitude
        );

        const modelTransform = {
            translateX: modelAsMercatorCoordinate.x,
            translateY: modelAsMercatorCoordinate.y,
            translateZ: modelAsMercatorCoordinate.z,
            rotateX: modelRotate[0],
            rotateY: modelRotate[1],
            rotateZ: modelRotate[2],
            scale: modelAsMercatorCoordinate.meterInMercatorCoordinateUnits()
        };

        const customLayer = {
            id: '3d-model',
            type: 'custom',
            renderingMode: '3d',
            onAdd(map, gl) {
                this.camera = new THREE.Camera();
                this.scene = new THREE.Scene();

                const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
                directionalLight.position.set(100, 100, 100);
                directionalLight.castShadow = true;
                this.scene.add(directionalLight);

                directionalLight.shadow.camera.near = 0.1;
                directionalLight.shadow.camera.far = 2000;
                directionalLight.shadow.camera.left = -500;
                directionalLight.shadow.camera.right = 500;
                directionalLight.shadow.camera.top = 500;
                directionalLight.shadow.camera.bottom = -500;

                directionalLight.shadow.mapSize.width = 4096;
                directionalLight.shadow.mapSize.height = 4096;

                const groundGeometry = new THREE.PlaneGeometry(1000, 1000);
                const groundMaterial = new THREE.ShadowMaterial({ opacity: 0.5 });
                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.rotation.x = -Math.PI / 2;
                ground.position.y = modelAsMercatorCoordinate.z;
                ground.receiveShadow = true;
                this.scene.add(ground);

                const loader = new GLTFLoader();
                loader.load(
                    'https://maplibre.org/maplibre-gl-js/docs/assets/34M_17/34M_17.gltf',
                    (gltf) => {
                        gltf.scene.traverse(function (node) {
                            if (node.isMesh || node.isLight) {
                                node.castShadow = true;
                                node.receiveShadow = true;
                            }
                        });
                        this.scene.add(gltf.scene);
                    }
                );
                this.map = map;

                this.renderer = new THREE.WebGLRenderer({
                    canvas: map.getCanvas(),
                    context: gl,
                    antialias: true
                });
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;

                this.renderer.autoClear = false;
            },
            render(gl, args) {
                const rotationX = new THREE.Matrix4().makeRotationAxis(
                    new THREE.Vector3(1, 0, 0),
                    modelTransform.rotateX
                );
                const rotationY = new THREE.Matrix4().makeRotationAxis(
                    new THREE.Vector3(0, 1, 0),
                    modelTransform.rotateY
                );
                const rotationZ = new THREE.Matrix4().makeRotationAxis(
                    new THREE.Vector3(0, 0, 1),
                    modelTransform.rotateZ
                );

                const m = new THREE.Matrix4().fromArray(args.defaultProjectionData.mainMatrix);
                const l = new THREE.Matrix4()
                    .makeTranslation(
                        modelTransform.translateX,
                        modelTransform.translateY,
                        modelTransform.translateZ
                    )
                    .scale(
                        new THREE.Vector3(
                            modelTransform.scale,
                            -modelTransform.scale,
                            modelTransform.scale
                        )
                    )
                    .multiply(rotationX)
                    .multiply(rotationY)
                    .multiply(rotationZ);

                this.camera.projectionMatrix = m.multiply(l);
                this.renderer.resetState();
                this.renderer.render(this.scene, this.camera);
                this.map.triggerRepaint();
            }
        };

        map.on('style.load', () => {
            map.addLayer(customLayer);
        });
    </script>
</body>

</html>
```

// FILE ./feature-properties-transform.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Use addProtocol to Transform Feature Properties</title>
    <meta property="og:description" content="Reverse country names with addProtocol in plain JavaScript." />
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="../../dist/maplibre-gl.css" />
    <script src="../../dist/maplibre-gl-dev.js"></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
    <div id="map"></div>
    <script type="module">
        import Protobuf from 'https://unpkg.com/pbf@4.0.1/index.js';
        import {VectorTile} from 'https://esm.run/@mapbox/vector-tile@2.0.3/index.js';
        import tileToProtobuf from 'https://esm.run/vt-pbf@3.1.3/index.js';

        const protocol = 'reverse';
        maplibregl.addProtocol(protocol, (request) => {
            const url = request.url.replace(protocol + '://', '');
            return fetch(url)
                .then((response) => response.arrayBuffer())
                .then((data) => new VectorTile(new Protobuf(data)))
                .then((tile) => ({
                    layers: Object.entries(tile.layers).reduce((acc, [layerId, layer]) => ({
                        ...acc,
                        [layerId]: {
                            ...layer,
                            feature: (index) => {
                                const feature = layer.feature(index);
                                if (feature.properties && typeof feature.properties['NAME'] === 'string') {
                                    feature.properties['NAME'] = feature.properties['NAME'].split('').reverse().join('');
                                }
                                if (feature.properties && typeof feature.properties['ABBREV'] === 'string') {
                                    feature.properties['ABBREV'] = feature.properties['ABBREV'].split('').reverse().join('');
                                }
                                return feature;
                            }
                        }
                    }), {})
                }))
                .then((tile) => tileToProtobuf(tile).buffer)
                .then((data) => ({ data }));
        });

        const map = new maplibregl.Map({
            container: 'map',
            style: 'https://demotiles.maplibre.org/style.json',
            center: [8, 47],
            zoom: 5,
            hash: 'map'
        });

        map.setTransformRequest((url, resourceType) => {
            if (url.startsWith('https://demotiles.maplibre.org/tiles/') && resourceType === 'Tile') {
                return { url: protocol + '://' + url };
            }
            return undefined;
        });
    </script>
</body>
</html>
```

// FILE ./sky-with-fog-and-terrain.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Sky, Fog, Terrain</title>
    <meta property="og:description" content="Allows changing the sky, fog and horizon color and blends." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
        .listing-group {
            font-family: 'Helvetica Neue', Arial, Helvetica, sans-serif;
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: #fff;
            background-color: gray;
            padding: 10px;
            border-radius: 4px;
        }
    </style>
</head>
<body>
<div id="map"></div>
<table id="listing-group" class="listing-group">
    <tr><td><label for="sky-enabled">enabled</label></td><td><input type="checkbox" id="sky-enabled" checked/></td></tr>
    <tr><td><label for="sky-color-picker">sky-color</label></td><td><input type="color" id="sky-color-picker" value="#0000ff" style="width: 100%"/></td></tr>
    <tr><td><label for="horizon-color-picker">horizon-color</label></td><td><input type="color" id="horizon-color-picker" value="#00ff00" style="width: 100%"/></td></tr>
    <tr><td><label for="fog-color-picker">fog-color</label></td><td><input type="color" id="fog-color-picker" value="#ff0000" style="width: 100%"/></td></tr>
    <tr><td><label for="sky-horizon-blend-slider">sky-horizon-blend</label></td><td><input type="range" id="sky-horizon-blend-slider" min="0" max="1" step="0.01" value="0.5" /></td></tr>
    <tr><td><label for="horizon-fog-blend-slider">horizon-fog-blend</label></td><td><input type="range" id="horizon-fog-blend-slider" min="0" max="1" step="0.01" value="0.5" /></td></tr>
    <tr><td><label for="fog-ground-blend-slider">fog-ground-blend</label></td><td><input type="range" id="fog-ground-blend-slider" min="0" max="1" step="0.01" value="0.1" /></td></tr>
</table>
<script>
    function setSkyFromUi() {
        if (!document.getElementById('sky-enabled').checked) {
            map.setSky(undefined);
            return;
        }
        map.setSky({
            'sky-color': document.getElementById('sky-color-picker').value,
            'sky-horizon-blend': +document.getElementById('sky-horizon-blend-slider').value,
            'horizon-color': document.getElementById('horizon-color-picker').value,
            'horizon-fog-blend': +document.getElementById('horizon-fog-blend-slider').value,
            'fog-color': document.getElementById('fog-color-picker').value,
            'fog-ground-blend': +document.getElementById('fog-ground-blend-slider').value
        });
    }

    const map = (window.map = new maplibregl.Map({
        container: 'map',
        zoom: 12,
        center: [11.2953, 47.5479],
        pitch: 77,
        hash: true,
        style: {
            version: 8,
            sources: {
                osm: {
                    type: 'raster',
                    tiles: ['https://a.tile.openstreetmap.org/{z}/{x}/{y}.png'],
                    tileSize: 256,
                    attribution: '&copy; OpenStreetMap Contributors',
                    maxzoom: 19
                },
                // Use a different source for terrain and hillshade layers, to improve render quality
                terrainSource: {
                    type: 'raster-dem',
                    url: 'https://demotiles.maplibre.org/terrain-tiles/tiles.json',
                    tileSize: 256
                },
                hillshadeSource: {
                    type: 'raster-dem',
                    url: 'https://demotiles.maplibre.org/terrain-tiles/tiles.json',
                    tileSize: 256
                }
            },
            layers: [
                {
                    id: 'osm',
                    type: 'raster',
                    source: 'osm'
                },
                {
                    id: 'hills',
                    type: 'hillshade',
                    source: 'hillshadeSource',
                    layout: {visibility: 'visible'},
                    paint: {'hillshade-shadow-color': '#473B24'}
                }
            ],
            terrain: {
                source: 'terrainSource',
                exaggeration: 1
            }
        },
        maxZoom: 18,
        maxPitch: 85
    }));

    map.addControl(
        new maplibregl.NavigationControl({
            visualizePitch: true,
            showZoom: true,
            showCompass: true
        })
    );


    map.addControl(
        new maplibregl.GlobeControl()
    );


    map.addControl(
        new maplibregl.TerrainControl({
            source: 'terrainSource',
            exaggeration: 1
        })
    );
    map.on('load', () => {
        document.getElementById('sky-color-picker').addEventListener('change', setSkyFromUi);
        document.getElementById('horizon-color-picker').addEventListener('change', setSkyFromUi);
        document.getElementById('fog-color-picker').addEventListener('change', setSkyFromUi);
        document.getElementById('sky-horizon-blend-slider').addEventListener('change', setSkyFromUi);
        document.getElementById('horizon-fog-blend-slider').addEventListener('change', setSkyFromUi);
        document.getElementById('fog-ground-blend-slider').addEventListener('change', setSkyFromUi);
        document.getElementById('sky-enabled').addEventListener('change', setSkyFromUi);
        setSkyFromUi();
    });
</script>
</body>
</html>
```

// FILE ./globe-3d-model.html
```
<!DOCTYPE html>
<html lang="en">

<head>
    <title>Add a 3D model to globe using three.js</title>
    <meta property="og:description" content="Use a custom style layer with three.js to add a 3D model to a globe." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body {
            margin: 0;
            padding: 0;
        }

        html,
        body,
        #map {
            height: 100%;
        }
        #project {
            display: block;
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translate(-50%);
            width: 50%;
            height: 40px;
            padding: 10px;
            border: none;
            border-radius: 3px;
            font-size: 12px;
            text-align: center;
            color: #fff;
            background: #ee8a65;
        }
    </style>
</head>

<body>
    <script type="importmap">
        {
            "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.169.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.169.0/examples/jsm/"
            }
        }
    </script>

    <div id="map"></div>
    <br />
    <button id="project">Toggle projection</button>
    <script type="module">

        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        const map = new maplibregl.Map({
            container: 'map',
            style: 'https://api.maptiler.com/maps/basic/style.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL',
            zoom: 5.5,
            center: [150.16546137527212, -35.017179237129994],
            maxPitch: 80,
            pitch: 70,
            canvasContextAttributes: {antialias: true} // create the gl context with MSAA antialiasing, so custom layers are antialiased
        });

        map.on('style.load', () => {
            map.setProjection({
                type: 'globe', // Set projection to globe
            });
        });

        // The API demonstrated in this example will work regardless of projection.
        // Click this button to toggle it.
        document.getElementById('project').addEventListener('click', () => {
            // Toggle projection
            const currentProjection = map.getProjection();
            map.setProjection({
                type: currentProjection.type === 'globe' ? 'mercator' : 'globe',
            });
        });

        // configuration of the custom layer for a 3D model per the CustomLayerInterface
        const customLayer = {
            id: '3d-model',
            type: 'custom',
            renderingMode: '3d', // The layer MUST be marked as 3D in order to get the proper depth buffer with globe depths in it.
            onAdd(map, gl) {
                this.camera = new THREE.Camera();
                this.scene = new THREE.Scene();

                // create two three.js lights to illuminate the model
                const directionalLight = new THREE.DirectionalLight(0xffffff);
                directionalLight.position.set(0, -70, 100).normalize();
                this.scene.add(directionalLight);

                const directionalLight2 = new THREE.DirectionalLight(0xffffff);
                directionalLight2.position.set(0, 70, 100).normalize();
                this.scene.add(directionalLight2);

                // use the three.js GLTF loader to add the 3D model to the three.js scene
                const loader = new GLTFLoader();
                loader.load(
                    'https://maplibre.org/maplibre-gl-js/docs/assets/34M_17/34M_17.gltf',
                    (gltf) => {
                        this.scene.add(gltf.scene);
                    }
                );
                this.map = map;

                // use the MapLibre GL JS map canvas for three.js
                this.renderer = new THREE.WebGLRenderer({
                    canvas: map.getCanvas(),
                    context: gl,
                    antialias: true
                });

                this.renderer.autoClear = false;
            },
            render(gl, args) {
                // parameters to ensure the model is georeferenced correctly on the map
                const modelOrigin = [148.9819, -35.39847];
                const modelAltitude = 0;

                // Make the object ~10s of km tall to make it visible at planetary scale.
                const scaling = 10_000.0;

                // We can use this API to get the correct model matrix.
                // It will work regardless of current projection.
                // See MapLibre source code, file "mercator_transform.ts" or "vertical_perspective_transform.ts".
                const modelMatrix = map.transform.getMatrixForModel(modelOrigin, modelAltitude);
                const m = new THREE.Matrix4().fromArray(args.defaultProjectionData.mainMatrix);
                const l = new THREE.Matrix4().fromArray(modelMatrix).scale(
                    new THREE.Vector3(
                        scaling,
                        scaling,
                        scaling
                    )
                );

                this.camera.projectionMatrix = m.multiply(l);
                this.renderer.resetState();
                this.renderer.render(this.scene, this.camera);
                this.map.triggerRepaint();
            }
        };

        map.on('style.load', () => {
            map.addLayer(customLayer);
        });
    </script>
</body>

</html>
```

// FILE ./live-update-feature.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Update a feature in realtime</title>
    <meta property="og:description" content="Change an existing feature on your map in real-time by updating its data." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<div id="map"></div>

<script src="https://d3js.org/d3.v3.min.js" charset="utf-8"></script>
<script>
    const map = new maplibregl.Map({
        container: 'map',
        style:
            'https://api.maptiler.com/maps/streets/style.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL',
        zoom: 0
    });

    map.on('load', () => {
        // We use D3 to fetch the JSON here so that we can parse and use it separately
        // from GL JS's use in the added source. You can use any request method (library
        // or otherwise) that you want.
        d3.json(
            'https://maplibre.org/maplibre-gl-js/docs/assets/hike.geojson',
            (err, data) => {
                if (err) throw err;

                // save full coordinate list for later
                const coordinates = data.features[0].geometry.coordinates;

                // start by showing just the first coordinate
                data.features[0].geometry.coordinates = [coordinates[0]];

                // add it to the map
                map.addSource('trace', {type: 'geojson', data});
                map.addLayer({
                    'id': 'trace',
                    'type': 'line',
                    'source': 'trace',
                    'paint': {
                        'line-color': 'yellow',
                        'line-opacity': 0.75,
                        'line-width': 5
                    }
                });

                // setup the viewport
                map.jumpTo({'center': coordinates[0], 'zoom': 14});
                map.setPitch(30);

                // on a regular basis, add more coordinates from the saved list and update the map
                let i = 0;
                const timer = window.setInterval(() => {
                    if (i < coordinates.length) {
                        data.features[0].geometry.coordinates.push(
                            coordinates[i]
                        );
                        map.getSource('trace').setData(data);
                        map.panTo(coordinates[i]);
                        i++;
                    } else {
                        window.clearInterval(timer);
                    }
                }, 10);
            }
        );
    });
</script>
</body>
</html>
```

// FILE ./geocoder.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Geocode with Nominatim</title>
    <meta property="og:description" content="Geocode with Nominatim and the maplibre-gl-geocoder plugin." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<!-- Load the `maplibre-gl-geocoder` plugin. -->
<script src="https://unpkg.com/@maplibre/maplibre-gl-geocoder@1.5.0/dist/maplibre-gl-geocoder.min.js"></script>
<link
    rel="stylesheet"
    href="https://unpkg.com/@maplibre/maplibre-gl-geocoder@1.5.0/dist/maplibre-gl-geocoder.css"
/>
<div id="map"></div>
<script>
    const map = new maplibregl.Map({
        container: 'map',
        // Use a minimalist raster style
        style: {
            'version': 8,
            'name': 'Blank',
            'center': [0, 0],
            'zoom': 0,
            'sources': {
                'raster-tiles': {
                    'type': 'raster',
                    'tiles': ['https://tile.openstreetmap.org/{z}/{x}/{y}.png'],
                    'tileSize': 256,
                    'minzoom': 0,
                    'maxzoom': 19
                }
            },
            'layers': [
                {
                    'id': 'background',
                    'type': 'background',
                    'paint': {
                        'background-color': '#e0dfdf'
                    }
                },
                {
                    'id': 'simple-tiles',
                    'type': 'raster',
                    'source': 'raster-tiles'
                }
            ],
            'id': 'blank'
        },
        center: [-87.61694, 41.86625],
        zoom: 15.99,
        pitch: 40,
        bearing: 20,
        canvasContextAttributes: {antialias: true}
    });

    const geocoderApi = {
        forwardGeocode: async (config) => {
            const features = [];
            try {
                const request =
            `https://nominatim.openstreetmap.org/search?q=${
                config.query
            }&format=geojson&polygon_geojson=1&addressdetails=1`;
                const response = await fetch(request);
                const geojson = await response.json();
                for (const feature of geojson.features) {
                    const center = [
                        feature.bbox[0] +
                    (feature.bbox[2] - feature.bbox[0]) / 2,
                        feature.bbox[1] +
                    (feature.bbox[3] - feature.bbox[1]) / 2
                    ];
                    const point = {
                        type: 'Feature',
                        geometry: {
                            type: 'Point',
                            coordinates: center
                        },
                        place_name: feature.properties.display_name,
                        properties: feature.properties,
                        text: feature.properties.display_name,
                        place_type: ['place'],
                        center
                    };
                    features.push(point);
                }
            } catch (e) {
                console.error(`Failed to forwardGeocode with error: ${e}`);
            }

            return {
                features
            };
        }
    };
    map.addControl(
        new MaplibreGeocoder(geocoderApi, {
            maplibregl
        })
    );
</script>
</body>
</html>
```

// FILE ./satellite-map.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Display a satellite map</title>
    <meta property="og:description" content="Display a satellite raster baselayer." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<div id="map"></div>
<script>
    const map = new maplibregl.Map({
        container: 'map',
        zoom: 9,
        center: [137.9150899566626, 36.25956997955441],
        style:
            'https://api.maptiler.com/maps/hybrid/style.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL'
    });
</script>
</body>
</html>
```

// FILE ./toggle-deckgl-layer.html
```
<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Toggle deck.gl layer</title>
    <meta property="og:description" content="Toggle deck.gl layer using maplibre." />
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" href="../../dist/maplibre-gl.css" />
    <script src="../../dist/maplibre-gl-dev.js"></script>
    <script src="https://unpkg.com/deck.gl@8.9.33/dist.min.js"></script>
    <style>
      body {
        margin: 0;
        padding: 0;
      }
      html,
      body,
      #map {
        height: 100%;
      }
      #toggle-button {
        position: fixed;
        top: 20px;
        left: 20px;
        background-color: rgb(130, 25, 191);
        color: #f0ead6;
        font-size: 1.2rem;
        min-width: 70px;
        border-radius: 5px;
        border: none;
        padding: 5px 10px;
        transition: 0.3s;
      }
      #toggle-button:hover {
        scale: 1.1;
        box-shadow: 0 0 4px 4px gray;
      }
      /* Deck.gl layer is added as an overlay, popup needs to be displayed over it */
      .maplibregl-popup {
        z-index: 2;
      }
    </style>
  </head>
  <body>
    <div id="map"></div>
    <button id="toggle-button">Hide</button>
    <script>
      const url = 'https://maps.clockworkmicro.com/streets/v1/style?x-api-key=';
      const apiKey = 'Dr4eW3s233rRkk8I_public';

      let overlay;

      const map = new maplibregl.Map({
          container: 'map',
          style: url + apiKey,
          center: [2.345885, 48.860412],
          zoom: 12,
      });
      map.addControl(new maplibregl.NavigationControl(), 'top-right');

      // 5 Beautiful gardens in Paris
      const sampleData = {
          type: 'FeatureCollection',
          name: 'Jardins Des Paris',
          crs: {
              type: 'name',
              properties: {name: 'urn:ogc:def:crs:OGC:1.3:CRS84'},
          },
          features: [
              {
                  type: 'Feature',
                  properties: {
                      name: 'Jardins du Trocadéro',
                      district: 16,
                  },
                  geometry: {
                      type: 'Point',
                      coordinates: [2.289207, 48.861561],
                  },
              },
              {
                  type: 'Feature',
                  properties: {
                      name: 'Jardin des Plantes',
                      district: 5,
                  },
                  geometry: {
                      type: 'Point',
                      coordinates: [2.359823, 48.843995],
                  },
              },
              {
                  type: 'Feature',
                  properties: {
                      name: 'Jardins das Tulherias',
                      district: 1,
                  },
                  geometry: {
                      type: 'Point',
                      coordinates: [2.327092, 48.863608],
                  },
              },
              {
                  type: 'Feature',
                  properties: {
                      name: 'Parc de Bercy',
                      district: 12,
                  },
                  geometry: {
                      type: 'Point',
                      coordinates: [2.382094, 48.835962],
                  },
              },
              {
                  type: 'Feature',
                  properties: {
                      name: 'Jardin du Luxemburg',
                      district: 6,
                  },
                  geometry: {
                      type: 'Point',
                      coordinates: [2.336975, 48.846421],
                  },
              },
          ],
      };

      // Add the overlay as a control
      function initializeOverlay () {
          const layer = new deck.ScatterplotLayer({
              id: 'scatterplot-layer',
              data: sampleData.features,
              pickable: true,
              opacity: 0.8,
              stroked: true,
              filled: true,
              radiusScale: 6,
              radiusMinPixels: 20,
              radiusMaxPixels: 100,
              lineWidthMinPixels: 5,
              getPosition: (d) => d.geometry.coordinates,
              getFillColor: (d) => [49, 130, 206],
              getLineColor: (d) => [175, 0, 32],
              onClick: (info) => {
                  const {coordinate, object} = info;
                  const description = `<div>
            <p>
              <strong>Name: </strong>${object.properties['name']}
            </p>
              <strong>District: </strong>${object.properties['district']}
            </p>
          </div>`;

                  new maplibregl.Popup()
                      .setLngLat(coordinate)
                      .setHTML(description)
                      .addTo(map);
              },
          });

          // Create the overlay
          overlay = new deck.MapboxOverlay({
              layers: [layer],
          });

          map.addControl(overlay);
      }

      let show = true; // Display the layer by default

      map.on('load', () => {
          // Add the overlay
          initializeOverlay();

          const toggleButton = document.querySelector('#toggle-button');
          toggleButton.addEventListener('click', () => {
              if (show) {
                  map.removeControl(overlay);
                  toggleButton.innerText = 'Show';
                  show = false;
              } else {
                  initializeOverlay();
                  toggleButton.innerText = 'Hide';
                  show = true;
              }
          });
      });
    </script>
  </body>
</html>
```

// FILE ./fullscreen.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>View a fullscreen map</title>
    <meta property="og:description" content="Toggle between current view and fullscreen mode. Does not work on iPhones because a pseudo-fullscreen is used, and the code is embedded in an iframe, which prevents the map from scaling." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<div id="map"></div>

<script>
    const map = new maplibregl.Map({
        container: 'map', // container id
        style:
            'https://api.maptiler.com/maps/streets/style.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL', //stylesheet location
        center: [11.255, 43.77], // starting position
        zoom: 13 // starting zoom
    });

    map.addControl(new maplibregl.FullscreenControl());
</script>
</body>
</html>
```

// FILE ./add-a-marker.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Add a default marker</title>
    <meta property="og:description" content="Add a default marker to the map." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<div id="map"></div>

<script>
    const map = new maplibregl.Map({
        container: 'map',
        style:
            'https://api.maptiler.com/maps/streets/style.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL',
        center: [12.550343, 55.665957],
        zoom: 8
    });

    const marker = new maplibregl.Marker()
        .setLngLat([12.550343, 55.665957])
        .addTo(map);
</script>
</body>
</html>
```

// FILE ./custom-marker-icons.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Add custom icons with Markers</title>
    <meta property="og:description" content="Add custom marker icons to your map." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<style>
    .marker {
        display: block;
        border: none;
        border-radius: 50%;
        cursor: pointer;
        padding: 0;
    }
</style>

<div id="map"></div>

<script>
    const geojson = {
        'type': 'FeatureCollection',
        'features': [
            {
                'type': 'Feature',
                'properties': {
                    'message': 'Foo',
                    'iconSize': [60, 60]
                },
                'geometry': {
                    'type': 'Point',
                    'coordinates': [-66.324462890625, -16.024695711685304]
                }
            },
            {
                'type': 'Feature',
                'properties': {
                    'message': 'Bar',
                    'iconSize': [50, 50]
                },
                'geometry': {
                    'type': 'Point',
                    'coordinates': [-61.2158203125, -15.97189158092897]
                }
            },
            {
                'type': 'Feature',
                'properties': {
                    'message': 'Baz',
                    'iconSize': [40, 40]
                },
                'geometry': {
                    'type': 'Point',
                    'coordinates': [-63.29223632812499, -18.28151823530889]
                }
            }
        ]
    };

    const map = new maplibregl.Map({
        container: 'map',
        style:
            'https://api.maptiler.com/maps/streets/style.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL',
        center: [-65.017, -16.457],
        zoom: 5
    });

    // add markers to map
    geojson.features.forEach((marker) => {
        // create a DOM element for the marker
        const el = document.createElement('div');
        el.className = 'marker';
        el.style.backgroundImage =
            `url(https://picsum.photos/${
                marker.properties.iconSize.join('/')
            }/)`;
        el.style.width = `${marker.properties.iconSize[0]}px`;
        el.style.height = `${marker.properties.iconSize[1]}px`;

        el.addEventListener('click', () => {
            window.alert(marker.properties.message);
        });

        // add marker to map
        new maplibregl.Marker({element: el})
            .setLngLat(marker.geometry.coordinates)
            .addTo(map);
    });
</script>
</body>
</html>
```

// FILE ./geojson-layer-in-stack.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Add a new layer below labels</title>
    <meta property="og:description" content="Use the second argument of addLayer to add a layer below labels." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<div id="map"></div>
<script>
    const map = new maplibregl.Map({
        container: 'map',
        style:
            'https://api.maptiler.com/maps/streets/style.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL',
        center: [-88.13734351262877, 35.137451890638886],
        zoom: 4
    });

    map.on('load', () => {
        const layers = map.getStyle().layers;
        // Find the index of the first symbol layer in the map style
        let firstSymbolId;
        for (let i = 0; i < layers.length; i++) {
            if (layers[i].type === 'symbol') {
                firstSymbolId = layers[i].id;
                break;
            }
        }
        map.addSource('urban-areas', {
            'type': 'geojson',
            'data':
                'https://d2ad6b4ur7yvpq.cloudfront.net/naturalearth-3.3.0/ne_50m_urban_areas.geojson'
        });
        map.addLayer(
            {
                'id': 'urban-areas-fill',
                'type': 'fill',
                'source': 'urban-areas',
                'layout': {},
                'paint': {
                    'fill-color': '#f08',
                    'fill-opacity': 0.4
                }
                // This is the important part of this example: the addLayer
                // method takes 2 arguments: the layer as an object, and a string
                // representing another layer's name. if the other layer
                // exists in the stylesheet already, the new layer will be positioned
                // right before that layer in the stack, making it possible to put
                // 'overlays' anywhere in the layer stack.
                // Insert the layer beneath the first symbol layer.
            },
            firstSymbolId
        );
    });
</script>
</body>
</html>
```

// FILE ./globe-atmosphere.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Display a globe with an atmosphere</title>
    <meta property="og:description" content="Display a globe with an atmosphere." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<style>
    #map {
        background: #000;
    }
</style>
<body>
<div id="map"></div>
<script>
    const map = new maplibregl.Map({
        container: 'map',
        zoom: 0,
        center: [137.9150899566626, 36.25956997955441],
        style: {
            'version': 8,
            'projection': {
                'type': 'globe'
            },
            'sources': {
                'satellite': {
                    'url': 'https://api.maptiler.com/tiles/satellite-v2/tiles.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL',
                    'type': 'raster'
                },
            },
            'layers': [
                {
                    'id': 'Satellite',
                    'type': 'raster',
                    'source': 'satellite',
                },
            ],
            'sky': {
                'atmosphere-blend': [
                    'interpolate',
                    ['linear'],
                    ['zoom'],
                    0, 1,
                    5, 1,
                    7, 0
                ]
            },
            'light': {
                'anchor': 'map',
                'position': [1.5, 90, 80]
            }
        }
    });
</script>
</body>
</html>
```

// FILE ./filter-within-layer.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Filter within a Layer</title>
    <meta property="og:description" content="Filter a layer based on user input using setFilter()." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<style>
    html, body, #map {
        height: 100%;
    }

    .map-overlay {
        font: 12px/20px 'Helvetica Neue', Arial, Helvetica, sans-serif;
        position: absolute;
        width: 31.8%;
        top: 0;
        left: 0;
        padding: 10px;
    }

    .map-overlay .map-overlay-inner {
        background-color: #fff;
        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
        border-radius: 3px;
        padding: 10px;
        margin-bottom: 10px;
    }

    .map-overlay input {
        margin: 2px;
    }

    input[type=number] {
        width: 25%
    }

    #filter-result {
        font-size: 8px;
        font-family: "Courier New";
    }
</style>
<div id="map"></div>

<div class="map-overlay top">
    <div class="map-overlay-inner">
        <nav id="nav-filter">
            <fieldset>
                <legend>🫨 Earthquake <code>felt</code>?</legend>
                <div>
                    <input id="felt" type="checkbox" />
                    <label for="felt">Apply <code>felt</code> Filter</label>
                    <div>
                        <div>
                            <label for="operator-felt">Operator:</label>
                            <select name="operator" id="operator-felt">
                                <option value=">">></option>
                                <option value="==" selected>==</option>
                                <option value="<"><</option>
                            </select>
                            <br>
                            <label for="range-felt">Felt:</label>
                            <input type="number" id="range-felt" name="range" value="4" min="1.0" max="10000" />
                        </div>
                    </div>
            </fieldset>

            <fieldset>
                <legend>📈 Magnitude</legend>
                <div>
                    <input id="mag" type="checkbox" />
                    <label for="mag">Apply <code>magnitude</code> Filter</label>
                    <div>
                        <div>
                            <label for="operator-mag">Operator:</label>
                            <select name="operator" id="operator-mag">
                                <option value=">">></option>
                                <option value="==" selected>==</option>
                                <option value="<"><</option>
                            </select>
                            <br>
                            <label for="range-mag">Magnitude:</label>
                            <input type="number" id="range-mag" name="range" value="2.71" min="0.0" max="100" />
                        </div>
                    </div>
            </fieldset>

            <fieldset>
                <legend>🌊 Tsunami (0 or 1)</legend>
                <input id="tsunami" type="checkbox" />
                <label for="tsunami">Apply <code>tsunami</code> filter</label>
                <div id="radio-tsunamis">
                    <input type="radio" id="t0" name="tsunami" value="0" /><label for="t0">0</label>
                    <input type="radio" id="t1" name="tsunami" value="1" /><label for="t1">1</label>
                </div>
            </fieldset>
        </nav>
        <hr />
        <div id='filter-result'>["all"]</div>
    </div>
</div>

<script>
    const data = {};

    const map = new maplibregl.Map({
        container: 'map',
        style: 'https://demotiles.maplibre.org/style.json',
        center: [-117, 32],
        zoom: 0,
    });

    map.on('load', () => {
        // add a clustered GeoJSON source for a sample set of earthquakes
        map.addSource('earthquakes', {
            'type': 'geojson',
            'data':
                'https://maplibre.org/maplibre-gl-js/docs/assets/earthquakes.geojson'
        });
        // Basic circle and symbol layers earthquakes
        map.addLayer({
            'id': 'earthquakes',
            'type': 'circle',
            'source': 'earthquakes',
            'paint': {
                'circle-color': '#ff0000'
            }
        });
    });

    document.getElementById('nav-filter').addEventListener('change', (e) => {
        let filterOnValue = ['all'];
        let operator = '==';

        switch (e.target.id) {
            /// example: `map.setFilter("earthquakes", ["any", [">", "felt", 16.0]])`
            case 'felt':
                operatorFelt = document.getElementById('operator-felt');
                felt = document.getElementById('range-felt');
                operator = operatorFelt.value;

                e.target.checked ? data.felt = Number(felt.value) : delete data['felt'];

                break;

            /// example: `map.setFilter("earthquakes", ["any", [">", "mag", 5.0]])`
            case 'mag':
                operatorMag = document.getElementById('operator-mag');
                mag = document.getElementById('range-mag');
                operator = operatorMag.value;

                e.target.checked ? data.mag = Number(mag.value) : delete data['mag'];

                break;

            /// example: `map.setFilter("earthquakes", ["any", [">", "tsunami", 0]])`
            case 'tsunami':
                tsunami = document.querySelector('input[type="radio"][name=tsunami]:checked');
                operator = '==';

                e.target.checked ? data.tsunami = Number(tsunami.value) : delete data['tsunami'];

                break;
            default:
                console.log('default');
        }

        filterOnValue = Object.keys(data);

        mapLibreFilterSpread = ['all', ...filterOnValue.map(id => [operator, id, data[id]])];
        mapLibreFilter = mapLibreFilterSpread;

        document.getElementById('filter-result').textContent = JSON.stringify(mapLibreFilter);

        map.setFilter('earthquakes', mapLibreFilter);
    });

</script>
</body>
</html>
```

// FILE ./language-switch.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Change a map's language</title>
    <meta property="og:description" content="Use setLayoutProperty to switch languages dynamically." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<style>
    #buttons {
        display: flex;
        justify-content: space-between;
        position: absolute;
        top: 20px;
        width: 90%;
    }
    .button {
        display: inline-block;
        cursor: pointer;
        width: 20%;
        padding: 8px;
        border-radius: 3px;
        margin-top: 10px;
        font-size: 12px;
        text-align: center;
        color: #fff;
        background: #ee8a65;
        font-family: sans-serif;
        font-weight: bold;
    }
</style>
<div id="map"></div>
<ul id="buttons">
    <li id="button-fr" class="button">French</li>
    <li id="button-ru" class="button">Russian</li>
    <li id="button-de" class="button">German</li>
    <li id="button-es" class="button">Spanish</li>
</ul>
<script>
    const map = new maplibregl.Map({
        container: 'map',
        style:
            'https://api.maptiler.com/maps/basic/style.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL',
        center: [16.05, 48],
        zoom: 2.9
    });

    document
        .getElementById('buttons')
        .addEventListener('click', (event) => {
            const language = event.target.id.substr('button-'.length);
            // Use setLayoutProperty to set the value of a layout property in a style layer.
            // The three arguments are the id of the layer, the name of the layout property,
            // and the new property value.
            map.setLayoutProperty('label_country', 'text-field', [
                'get',
                `name:${language}`
            ]);
        });
</script>
</body>
</html>
```

// FILE ./heatmap-layer.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Create a heatmap layer</title>
    <meta property="og:description" content="Visualize earthquake frequency by location using a heatmap layer." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<div id="map"></div>

<script>
    const map = new maplibregl.Map({
        container: 'map',
        style:
            'https://api.maptiler.com/maps/basic/style.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL',
        center: [-120, 50],
        zoom: 2
    });

    map.on('load', () => {
        // Add a geojson point source.
        // Heatmap layers also work with a vector tile source.
        map.addSource('earthquakes', {
            'type': 'geojson',
            'data':
                'https://maplibre.org/maplibre-gl-js/docs/assets/earthquakes.geojson'
        });

        map.addLayer(
            {
                'id': 'earthquakes-heat',
                'type': 'heatmap',
                'source': 'earthquakes',
                'maxzoom': 9,
                'paint': {
                    // Increase the heatmap weight based on frequency and property magnitude
                    'heatmap-weight': [
                        'interpolate',
                        ['linear'],
                        ['get', 'mag'],
                        0,
                        0,
                        6,
                        1
                    ],
                    // Increase the heatmap color weight weight by zoom level
                    // heatmap-intensity is a multiplier on top of heatmap-weight
                    'heatmap-intensity': [
                        'interpolate',
                        ['linear'],
                        ['zoom'],
                        0,
                        1,
                        9,
                        3
                    ],
                    // Color ramp for heatmap.  Domain is 0 (low) to 1 (high).
                    // Begin color ramp at 0-stop with a 0-transparency color
                    // to create a blur-like effect.
                    'heatmap-color': [
                        'interpolate',
                        ['linear'],
                        ['heatmap-density'],
                        0,
                        'rgba(33,102,172,0)',
                        0.2,
                        'rgb(103,169,207)',
                        0.4,
                        'rgb(209,229,240)',
                        0.6,
                        'rgb(253,219,199)',
                        0.8,
                        'rgb(239,138,98)',
                        1,
                        'rgb(178,24,43)'
                    ],
                    // Adjust the heatmap radius by zoom level
                    'heatmap-radius': [
                        'interpolate',
                        ['linear'],
                        ['zoom'],
                        0,
                        2,
                        9,
                        20
                    ],
                    // Transition from heatmap to circle layer by zoom level
                    'heatmap-opacity': [
                        'interpolate',
                        ['linear'],
                        ['zoom'],
                        7,
                        1,
                        9,
                        0
                    ]
                }
            },
            'waterway'
        );

        map.addLayer(
            {
                'id': 'earthquakes-point',
                'type': 'circle',
                'source': 'earthquakes',
                'minzoom': 7,
                'paint': {
                    // Size circle radius by earthquake magnitude and zoom level
                    'circle-radius': [
                        'interpolate',
                        ['linear'],
                        ['zoom'],
                        7,
                        ['interpolate', ['linear'], ['get', 'mag'], 1, 1, 6, 4],
                        16,
                        ['interpolate', ['linear'], ['get', 'mag'], 1, 5, 6, 50]
                    ],
                    // Color circle by earthquake magnitude
                    'circle-color': [
                        'interpolate',
                        ['linear'],
                        ['get', 'mag'],
                        1,
                        'rgba(33,102,172,0)',
                        2,
                        'rgb(103,169,207)',
                        3,
                        'rgb(209,229,240)',
                        4,
                        'rgb(253,219,199)',
                        5,
                        'rgb(239,138,98)',
                        6,
                        'rgb(178,24,43)'
                    ],
                    'circle-stroke-color': 'white',
                    'circle-stroke-width': 1,
                    // Transition from heatmap to circle layer by zoom level
                    'circle-opacity': [
                        'interpolate',
                        ['linear'],
                        ['zoom'],
                        7,
                        0,
                        8,
                        1
                    ]
                }
            },
            'waterway'
        );
    });
</script>
</body>
</html>
```

// FILE ./color-switcher.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Change a layer's color with buttons</title>
    <meta property="og:description" content="Use setPaintProperty to change a layer's fill color." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<style>
    .map-overlay {
        font: 12px/20px 'Helvetica Neue', Arial, Helvetica, sans-serif;
        position: absolute;
        width: 200px;
        top: 0;
        left: 0;
        padding: 10px;
    }

    .map-overlay .map-overlay-inner {
        background-color: #fff;
        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
        border-radius: 3px;
        padding: 10px;
        margin-bottom: 10px;
    }

    .map-overlay-inner fieldset {
        border: none;
        padding: 0;
        margin: 0 0 10px;
    }

    .map-overlay-inner fieldset:last-child {
        margin: 0;
    }

    .map-overlay-inner select {
        width: 100%;
    }

    .map-overlay-inner label {
        display: block;
        font-weight: bold;
        margin: 0 0 5px;
    }

    .map-overlay-inner button {
        display: inline-block;
        width: 36px;
        height: 20px;
        border: none;
        cursor: pointer;
    }

    .map-overlay-inner button:focus {
        outline: none;
    }

    .map-overlay-inner button:hover {
        box-shadow: inset 0 0 0 3px rgba(0, 0, 0, 0.1);
    }
</style>

<div id="map"></div>
<div class="map-overlay top">
    <div class="map-overlay-inner">
        <fieldset>
            <label for="layer">Select layer</label>
            <select id="layer" name="layer">
                <option value="water">Water</option>
                <option value="building-3d">Buildings</option>
            </select>
        </fieldset>
        <fieldset>
            <label>Choose a color</label>
            <div id="swatches"></div>
        </fieldset>
    </div>
</div>

<script>
    const map = new maplibregl.Map({
        container: 'map',
        style: 'https://api.maptiler.com/maps/streets/style.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL',
        center: [12.338, 45.4385],
        zoom: 17.4
    });

    const swatches = document.getElementById('swatches');
    const layer = document.getElementById('layer');
    const colors = [
        '#ffffcc',
        '#a1dab4',
        '#41b6c4',
        '#2c7fb8',
        '#253494',
        '#fed976',
        '#feb24c',
        '#fd8d3c',
        '#f03b20',
        '#bd0026'
    ];

    colors.forEach((color) => {
        const swatch = document.createElement('button');
        swatch.style.backgroundColor = color;
        swatch.addEventListener('click', () => {
            map.setPaintProperty(
                layer.value,
                layer.value === 'water' ? 'fill-color' : 'fill-extrusion-color',
                color
            );
        });
        swatches.appendChild(swatch);
    });
</script>
</body>
</html>
```

// FILE ./visualize-population-density.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Visualize population density</title>
    <meta property="og:description" content="Use a variable binding expression to calculate and display population density." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<div id="map"></div>
<script>
    const map = new maplibregl.Map({
        container: 'map', // container id
        style:
            'https://api.maptiler.com/maps/streets/style.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL', // stylesheet location
        center: [30.0222, -1.9596], // starting position [lng, lat]
        zoom: 7 // starting zoom
    });

    map.on('load', () => {
        map.addSource('rwanda-provinces', {
            'type': 'geojson',
            'data':
                'https://maplibre.org/maplibre-gl-js/docs/assets/rwanda-provinces.geojson'
        });
        map.addLayer({
            'id': 'rwanda-provinces',
            'type': 'fill',
            'source': 'rwanda-provinces',
            'layout': {},
            'paint': {
                'fill-color': [
                    'let',
                    'density',
                    ['/', ['get', 'population'], ['get', 'sq-km']],
                    [
                        'interpolate',
                        ['linear'],
                        ['zoom'],
                        8,
                        [
                            'interpolate',
                            ['linear'],
                            ['var', 'density'],
                            274,
                            ['to-color', '#edf8e9'],
                            1551,
                            ['to-color', '#006d2c']
                        ],
                        10,
                        [
                            'interpolate',
                            ['linear'],
                            ['var', 'density'],
                            274,
                            ['to-color', '#eff3ff'],
                            1551,
                            ['to-color', '#08519c']
                        ]
                    ]
                ],
                'fill-opacity': 0.7
            }
        });
    });
</script>
</body>
</html>
```

// FILE ./queryrenderedfeatures.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Get features under the mouse pointer</title>
    <meta property="og:description" content="Use queryRenderedFeatures to show properties of hovered-over map elements." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<style>
    #features {
        position: absolute;
        top: 0;
        right: 0;
        bottom: 0;
        width: 50%;
        overflow: auto;
        background: rgba(255, 255, 255, 0.8);
    }
    #map canvas {
        cursor: crosshair;
    }
</style>
<div id="map"></div>
<pre id="features"></pre>
<script>
    const map = new maplibregl.Map({
        container: 'map',
        style:
            'https://api.maptiler.com/maps/streets/style.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL',
        center: [-96, 37.8],
        zoom: 3
    });

    map.on('mousemove', (e) => {
        const features = map.queryRenderedFeatures(e.point);

        // Limit the number of properties we're displaying for
        // legibility and performance
        const displayProperties = [
            'type',
            'properties',
            'id',
            'layer',
            'source',
            'sourceLayer',
            'state'
        ];

        const displayFeatures = features.map((feat) => {
            const displayFeat = {};
            displayProperties.forEach((prop) => {
                displayFeat[prop] = feat[prop];
            });
            return displayFeat;
        });

        document.getElementById('features').innerHTML = JSON.stringify(
            displayFeatures,
            null,
            2
        );
    });
</script>
</body>
</html>
```

// FILE ./animate-point-along-line.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Animate a point</title>
    <meta property="og:description" content="Animate the position of a point by updating a GeoJSON source on each frame." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<div id="map"></div>
<script>
    const map = new maplibregl.Map({
        container: 'map',
        style:
            'https://api.maptiler.com/maps/streets/style.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL',
        center: [0, 0],
        zoom: 2
    });

    const radius = 20;

    function pointOnCircle(angle) {
        return {
            'type': 'Point',
            'coordinates': [Math.cos(angle) * radius, Math.sin(angle) * radius]
        };
    }

    map.on('load', () => {
        // Add a source and layer displaying a point which will be animated in a circle.
        map.addSource('point', {
            'type': 'geojson',
            'data': pointOnCircle(0)
        });

        map.addLayer({
            'id': 'point',
            'source': 'point',
            'type': 'circle',
            'paint': {
                'circle-radius': 10,
                'circle-color': '#007cbf'
            }
        });

        function animateMarker(timestamp) {
            // Update the data to a new position based on the animation timestamp. The
            // divisor in the expression `timestamp / 1000` controls the animation speed.
            map.getSource('point').setData(pointOnCircle(timestamp / 1000));

            // Request the next frame of the animation.
            requestAnimationFrame(animateMarker);
        }

        // Start the animation.
        animateMarker(0);
    });
</script>
</body>
</html>
```

// FILE ./measure.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Measure distances</title>
    <meta property="og:description" content="Click points on a map to create lines that measure distanced using turf.length." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<style>
    .distance-container {
        position: absolute;
        top: 10px;
        left: 10px;
        z-index: 1;
    }

    .distance-container > * {
        background-color: rgba(0, 0, 0, 0.5);
        color: #fff;
        font-size: 11px;
        line-height: 18px;
        display: block;
        margin: 0;
        padding: 5px 10px;
        border-radius: 3px;
    }
</style>

<div id="map"></div>
<div id="distance" class="distance-container"></div>

<script src="https://cdn.jsdelivr.net/npm/@turf/turf@7/turf.min.js"></script>
<script>
    const map = new maplibregl.Map({
        container: 'map',
        style:
            'https://api.maptiler.com/maps/streets/style.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL',
        center: [2.3399, 48.8555],
        zoom: 12
    });

    const distanceContainer = document.getElementById('distance');

    // GeoJSON object to hold our measurement features
    const geojson = {
        'type': 'FeatureCollection',
        'features': []
    };

    // Used to draw a line between points
    const linestring = {
        'type': 'Feature',
        'geometry': {
            'type': 'LineString',
            'coordinates': []
        }
    };

    map.on('load', () => {
        map.addSource('geojson', {
            'type': 'geojson',
            'data': geojson
        });

        // Add styles to the map
        map.addLayer({
            id: 'measure-points',
            type: 'circle',
            source: 'geojson',
            paint: {
                'circle-radius': 5,
                'circle-color': '#000'
            },
            filter: ['in', '$type', 'Point']
        });
        map.addLayer({
            id: 'measure-lines',
            type: 'line',
            source: 'geojson',
            layout: {
                'line-cap': 'round',
                'line-join': 'round'
            },
            paint: {
                'line-color': '#000',
                'line-width': 2.5
            },
            filter: ['in', '$type', 'LineString']
        });

        map.on('click', (e) => {
            const features = map.queryRenderedFeatures(e.point, {
                layers: ['measure-points']
            });

            // Remove the linestring from the group
            // So we can redraw it based on the points collection
            if (geojson.features.length > 1) geojson.features.pop();

            // Clear the Distance container to populate it with a new value
            distanceContainer.innerHTML = '';

            // If a feature was clicked, remove it from the map
            if (features.length) {
                const id = features[0].properties.id;
                geojson.features = geojson.features.filter((point) => {
                    return point.properties.id !== id;
                });
            } else {
                const point = {
                    'type': 'Feature',
                    'geometry': {
                        'type': 'Point',
                        'coordinates': [e.lngLat.lng, e.lngLat.lat]
                    },
                    'properties': {
                        'id': String(new Date().getTime())
                    }
                };

                geojson.features.push(point);
            }

            if (geojson.features.length > 1) {
                linestring.geometry.coordinates = geojson.features.map(
                    (point) => {
                        return point.geometry.coordinates;
                    }
                );

                geojson.features.push(linestring);

                // Populate the distanceContainer with total distance
                const value = document.createElement('pre');
                value.textContent =
                    `Total distance: ${
                        turf.length(linestring).toLocaleString()
                    }km`;
                distanceContainer.appendChild(value);
            }

            map.getSource('geojson').setData(geojson);
        });
    });

    map.on('mousemove', (e) => {
        const features = map.queryRenderedFeatures(e.point, {
            layers: ['measure-points']
        });
        // UI indicator for clicking/hovering a point on the map
        map.getCanvas().style.cursor = features.length ?
            'pointer' :
            'crosshair';
    });
</script>
</body>
</html>
```

// FILE ./mouse-position.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Get coordinates of the mouse pointer</title>
    <meta property="og:description" content="Show mouse position on hover with pixel and latitude and longitude coordinates." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<style>
    #info {
        display: block;
        position: absolute;
        top: 20px;
        left: 50%;
        transform: translate(-50%);
        width: 50%;
        padding: 10px;
        border: none;
        border-radius: 3px;
        font-size: 12px;
        text-align: center;
        color: #222;
        background: #fff;
    }
</style>
<div id="map"></div>
<pre id="info"></pre>
<script>
    const map = new maplibregl.Map({
        container: 'map', // container id
        style:
            'https://api.maptiler.com/maps/streets/style.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL',
        center: [-74.5, 40], // starting position
        zoom: 9 // starting zoom
    });

    map.on('mousemove', (e) => {
        document.getElementById('info').innerHTML =
            // e.point is the x, y coordinates of the mousemove event relative
            // to the top-left corner of the map
            `${JSON.stringify(e.point)
            }<br />${
                // e.lngLat is the longitude, latitude geographical position of the event
                JSON.stringify(e.lngLat.wrap())}`;
    });
</script>
</body>
</html>
```

// FILE ./set-popup.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Attach a popup to a marker instance</title>
    <meta property="og:description" content="Attach a popup to a marker and display it on click." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<style>
    #marker {
        background-image: url('https://maplibre.org/maplibre-gl-js/docs/assets/washington-monument.jpg');
        background-size: cover;
        width: 50px;
        height: 50px;
        border-radius: 50%;
        cursor: pointer;
    }

    .maplibregl-popup {
        max-width: 200px;
    }
</style>

<div id="map"></div>

<script>
    const monument = [-77.0353, 38.8895];
    const map = new maplibregl.Map({
        container: 'map',
        style: 'https://api.maptiler.com/maps/streets/style.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL',
        center: monument,
        zoom: 15
    });

    // create the popup
    const popup = new maplibregl.Popup({offset: 25}).setText(
        'Construction on the Washington Monument began in 1848.'
    );

    // create DOM element for the marker
    const el = document.createElement('div');
    el.id = 'marker';

    // create the marker
    new maplibregl.Marker({element: el})
        .setLngLat(monument)
        .setPopup(popup) // sets a popup on this marker
        .addTo(map);
</script>
</body>
</html>
```

// FILE ./filter-markers-by-input.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Filter symbols by text input</title>
    <meta property="og:description" content="Filter symbols by icon name by typing in a text input." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<style>
    .filter-ctrl {
        position: absolute;
        top: 10px;
        right: 10px;
        z-index: 1;
    }

    .filter-ctrl input[type='text'] {
        font: 12px/20px 'Helvetica Neue', Arial, Helvetica, sans-serif;
        width: 100%;
        border: 0;
        background-color: #fff;
        margin: 0;
        color: rgba(0, 0, 0, 0.5);
        padding: 10px;
        box-shadow: 0 0 0 2px rgba(0, 0, 0, 0.1);
        border-radius: 3px;
        width: 180px;
    }
</style>
<div id="map"></div>
<div class="filter-ctrl">
    <input
        id="filter-input"
        type="text"
        name="filter"
        placeholder="Filter by name"
    />
</div>

<script>
    const places = {
        'type': 'FeatureCollection',
        'features': [
            {
                'type': 'Feature',
                'properties': {
                    'icon': 'theatre'
                },
                'geometry': {
                    'type': 'Point',
                    'coordinates': [-77.038659, 38.931567]
                }
            },
            {
                'type': 'Feature',
                'properties': {
                    'icon': 'theatre'
                },
                'geometry': {
                    'type': 'Point',
                    'coordinates': [-77.003168, 38.894651]
                }
            },
            {
                'type': 'Feature',
                'properties': {
                    'icon': 'bar'
                },
                'geometry': {
                    'type': 'Point',
                    'coordinates': [-77.090372, 38.881189]
                }
            },
            {
                'type': 'Feature',
                'properties': {
                    'icon': 'bicycle'
                },
                'geometry': {
                    'type': 'Point',
                    'coordinates': [-77.052477, 38.943951]
                }
            },
            {
                'type': 'Feature',
                'properties': {
                    'icon': 'music'
                },
                'geometry': {
                    'type': 'Point',
                    'coordinates': [-77.031706, 38.914581]
                }
            },
            {
                'type': 'Feature',
                'properties': {
                    'icon': 'music'
                },
                'geometry': {
                    'type': 'Point',
                    'coordinates': [-77.020945, 38.878241]
                }
            },
            {
                'type': 'Feature',
                'properties': {
                    'icon': 'music'
                },
                'geometry': {
                    'type': 'Point',
                    'coordinates': [-77.007481, 38.876516]
                }
            }
        ]
    };

    const layerIDs = []; // Will contain a list used to filter against.
    const filterInput = document.getElementById('filter-input');
    const map = new maplibregl.Map({
        container: 'map',
        style:
            'https://api.maptiler.com/maps/streets/style.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL',
        center: [-77.04, 38.907],
        zoom: 11.15
    });

    map.on('load', () => {
        // Add a GeoJSON source containing place coordinates and information.
        map.addSource('places', {
            'type': 'geojson',
            'data': places
        });

        places.features.forEach((feature) => {
            const symbol = feature.properties['icon'];
            const layerID = `poi-${symbol}`;

            // Add a layer for this symbol type if it hasn't been added already.
            if (!map.getLayer(layerID)) {
                map.addLayer({
                    'id': layerID,
                    'type': 'symbol',
                    'source': 'places',
                    'layout': {
                        'icon-image': `${symbol}_15`,
                        'icon-overlap': 'always',
                        'text-field': symbol,
                        'text-font': [
                            'Open Sans Bold',
                            'Arial Unicode MS Bold'
                        ],
                        'text-size': 11,
                        'text-transform': 'uppercase',
                        'text-letter-spacing': 0.05,
                        'text-offset': [0, 1.5]
                    },
                    'paint': {
                        'text-color': '#202',
                        'text-halo-color': '#fff',
                        'text-halo-width': 2
                    },
                    'filter': ['==', 'icon', symbol]
                });

                layerIDs.push(layerID);
            }
        });

        filterInput.addEventListener('keyup', (e) => {
            // If the input value matches a layerID set
            // it's visibility to 'visible' or else hide it.
            const value = e.target.value.trim().toLowerCase();
            layerIDs.forEach((layerID) => {
                map.setLayoutProperty(
                    layerID,
                    'visibility',
                    layerID.indexOf(value) > -1 ? 'visible' : 'none'
                );
            });
        });
    });
</script>
</body>
</html>
```

// FILE ./pmtiles.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>PMTiles source and protocol</title>
    <meta property="og:description" content="Uses the PMTiles plugin and protocol to present a map." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <script src="https://unpkg.com/pmtiles@3.2.0/dist/pmtiles.js"></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<div id="map"></div>
<script>
    
    // add the PMTiles plugin to the maplibregl global.
    const protocol = new pmtiles.Protocol();
    maplibregl.addProtocol('pmtiles', protocol.tile);

    const PMTILES_URL = 'https://pmtiles.io/protomaps(vector)ODbL_firenze.pmtiles';

    const p = new pmtiles.PMTiles(PMTILES_URL);

    // this is so we share one instance across the JS code and the map renderer
    protocol.add(p);

    // we first fetch the header so we can get the center lon, lat of the map.
    p.getHeader().then(h => {
        const map = new maplibregl.Map({
            container: 'map',
            zoom: h.maxZoom - 2,
            center: [h.centerLon, h.centerLat],
            style: {
                version: 8,
                sources: {
                    'example_source': {
                        type: 'vector',
                        url: `pmtiles://${PMTILES_URL}`,
                        attribution: '© <a href="https://openstreetmap.org/copyright">OpenStreetMap</a>'
                    }
                },
                layers: [
                    {
                        'id': 'buildings',
                        'source': 'example_source',
                        'source-layer': 'landuse',
                        'type': 'fill',
                        'paint': {
                            'fill-color': 'steelblue'
                        }
                    },
                    {
                        'id': 'roads',
                        'source': 'example_source',
                        'source-layer': 'roads',
                        'type': 'line',
                        'paint': {
                            'line-color': 'black'
                        }
                    },
                    {
                        'id': 'mask',
                        'source': 'example_source',
                        'source-layer': 'mask',
                        'type': 'fill',
                        'paint': {
                            'fill-color': 'white'
                        }
                    }
                ]
            }
        });
    });
</script>
</body>
</html>
```

// FILE ./local-geojson-experimental.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>View local GeoJSON (experimental)</title>
    <meta property="og:description" content="View local GeoJSON with experimental File System Access API." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<style>
    #viewbutton {
        position: absolute;
        top: 0;
        left: 0;
    }
</style>
<div id="map"></div>
<button id="viewbutton">View local GeoJSON file</button>
<script>
    const map = new maplibregl.Map({
        container: 'map',
        style:
            'https://api.maptiler.com/maps/streets/style.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL',
        center: [-8.3226655, 53.7654751],
        zoom: 8
    });

    const viewbutton = document.getElementById('viewbutton');

    async function buttonClickHandler() {
        const [fileHandle] = await window.showOpenFilePicker({
            // allow only single file
            multiple: false,

            // apply filter for GeoJSON files
            types: [
                {
                    description: 'GeoJSON',
                    accept: {'application/geo+json': ['.geojson']}
                }
            ],

            // start in download directory
            startIn: 'downloads'
        });

        // get file handle and read content
        const file = await fileHandle.getFile();
        const contents = await file.text();

        // parse file as json and add as source to the map
        map.addSource('uploaded-source', {
            'type': 'geojson',
            'data': JSON.parse(contents)
        });

        map.addLayer({
            'id': 'uploaded-polygons',
            'type': 'fill',
            'source': 'uploaded-source',
            'paint': {
                'fill-color': '#888888',
                'fill-outline-color': 'red',
                'fill-opacity': 0.4
            },
            // filter for (multi)polygons; for also displaying linestrings
            // or points add more layers with different filters
            'filter': ['==', '$type', 'Polygon']
        });
    }

    if ('showOpenFilePicker' in window) {
        viewbutton.addEventListener('click', buttonClickHandler);
    } else {
        viewbutton.innerText =
            'Your browser does not support File System Access API';
        // If you want a fallback, try <input type="file">; but this uses classical file upload
    }
</script>
</body>
</html>
```

// FILE ./vector-source.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Add a vector tile source</title>
    <meta property="og:description" content="Add a vector source to a map." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<div id="map"></div>
<script>
    const map = new maplibregl.Map({
        container: 'map',
        style:
            'https://api.maptiler.com/maps/streets/style.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL',
        zoom: 13,
        center: [-122.447303, 37.753574]
    });

    map.on('load', () => {
        map.addSource('contours', {
            type: 'vector',
            url:
                'https://api.maptiler.com/tiles/contours/tiles.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL'
        });
        map.addLayer({
            'id': 'terrain-data',
            'type': 'line',
            'source': 'contours',
            'source-layer': 'contour',
            'layout': {
                'line-join': 'round',
                'line-cap': 'round'
            },
            'paint': {
                'line-color': '#ff69b4',
                'line-width': 1
            }
        });
    });
</script>
</body>
</html>
```

// FILE ./contour-lines.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Add Contour Lines</title>
    <meta property="og:description" content="Add contour lines to your map from a raster-dem source." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<div id="map"></div>
<script src="https://unpkg.com/maplibre-contour@0.0.5/dist/index.min.js"></script>
<script>
    const demSource = new mlcontour.DemSource({
        url: 'https://demotiles.maplibre.org/terrain-tiles/{z}/{x}/{y}.png',
        encoding: 'mapbox',
        maxzoom: 12,
        // offload contour line computation to a web worker
        worker: true
    });

    // calls maplibregl.addProtocol to register a dynamic vector tile provider that
    // downloads raster-dem tiles, computes contour lines, and encodes as a vector
    // tile for each tile request from maplibre
    demSource.setupMaplibre(maplibregl);

    const map = (window.map = new maplibregl.Map({
        container: 'map',
        zoom: 13,
        center: [11.3229, 47.2738],
        hash: true,
        style: {
            version: 8,
            glyphs: 'https://demotiles.maplibre.org/font/{fontstack}/{range}.pbf',
            sources: {
                hillshadeSource: {
                    type: 'raster-dem',
                    // share cached raster-dem tiles with the contour source
                    tiles: [demSource.sharedDemProtocolUrl],
                    tileSize: 512,
                    maxzoom: 12
                },
                contourSourceFeet: {
                    type: 'vector',
                    tiles: [
                        demSource.contourProtocolUrl({
                        // meters to feet
                            multiplier: 3.28084,
                            overzoom: 1,
                            thresholds: {
                            // zoom: [minor, major]
                                11: [200, 1000],
                                12: [100, 500],
                                13: [100, 500],
                                14: [50, 200],
                                15: [20, 100]
                            },
                            elevationKey: 'ele',
                            levelKey: 'level',
                            contourLayer: 'contours'
                        })
                    ],
                    maxzoom: 15
                }
            },
            layers: [
                {
                    id: 'hills',
                    type: 'hillshade',
                    source: 'hillshadeSource',
                    layout: {visibility: 'visible'},
                    paint: {'hillshade-exaggeration': 0.25}
                },
                {
                    id: 'contours',
                    type: 'line',
                    source: 'contourSourceFeet',
                    'source-layer': 'contours',
                    paint: {
                        'line-opacity': 0.5,
                        // "major" contours have level=1, "minor" have level=0
                        'line-width': ['match', ['get', 'level'], 1, 1, 0.5]
                    }
                },
                {
                    id: 'contour-text',
                    type: 'symbol',
                    source: 'contourSourceFeet',
                    'source-layer': 'contours',
                    filter: ['>', ['get', 'level'], 0],
                    paint: {
                        'text-halo-color': 'white',
                        'text-halo-width': 1
                    },
                    layout: {
                        'symbol-placement': 'line',
                        'text-size': 10,
                        'text-field': [
                            'concat',
                            ['number-format', ['get', 'ele'], {}],
                            '\''
                        ],
                        'text-font': ['Noto Sans Bold']
                    }
                }
            ]
        }
    }));
</script>
</body>
</html>
```

// FILE ./display-and-style-rich-text-labels.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Display and style rich text labels</title>
    <meta property="og:description" content="Use the format expression to display country labels in both English and in the local language." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<div id="map"></div>
<script>
    maplibregl.setRTLTextPlugin(
        'https://unpkg.com/@mapbox/mapbox-gl-rtl-text@0.3.0/dist/mapbox-gl-rtl-text.js'
    );

    const map = new maplibregl.Map({
        container: 'map', // container id
        style:
            'https://api.maptiler.com/maps/basic/style.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL', // stylesheet location
        center: [9.49, 49.01], // starting position [lng, lat]
        zoom: 4 // starting zoom
    });

    map.on('load', () => {
        map.setLayoutProperty('label_country', 'text-field', [
            'format',
            ['get', 'name_en'],
            {'font-scale': 1.2},
            '
',
            {},
            ['get', 'name'],
            {
                'font-scale': 0.8,
                'text-font': [
                    'literal',
                    ['DIN Offc Pro Italic', 'Arial Unicode MS Regular']
                ]
            }
        ]);
    });
</script>
</body>
</html>
```

// FILE ./popup-on-click.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Display a popup on click</title>
    <meta property="og:description" content="When a user clicks a symbol, show a popup containing more information." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<style>
    .maplibregl-popup {
        max-width: 400px;
        font: 12px/20px 'Helvetica Neue', Arial, Helvetica, sans-serif;
    }
</style>
<div id="map"></div>
<script>
    const map = new maplibregl.Map({
        container: 'map',
        style: 'https://api.maptiler.com/maps/streets/style.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL',
        center: [-77.04, 38.907],
        zoom: 11.15
    });

    map.on('load', () => {
        map.addSource('places', {
            'type': 'geojson',
            'data': {
                'type': 'FeatureCollection',
                'features': [
                    {
                        'type': 'Feature',
                        'properties': {
                            'description':
                                '<strong>Make it Mount Pleasant</strong><p><a href="http://www.mtpleasantdc.com/makeitmtpleasant" target="_blank" title="Opens in a new window">Make it Mount Pleasant</a> is a handmade and vintage market and afternoon of live entertainment and kids activities. 12:00-6:00 p.m.</p>',
                            'icon': 'theatre'
                        },
                        'geometry': {
                            'type': 'Point',
                            'coordinates': [-77.038659, 38.931567]
                        }
                    },
                    {
                        'type': 'Feature',
                        'properties': {
                            'description':
                                '<strong>Mad Men Season Five Finale Watch Party</strong><p>Head to Lounge 201 (201 Massachusetts Avenue NE) Sunday for a <a href="http://madmens5finale.eventbrite.com/" target="_blank" title="Opens in a new window">Mad Men Season Five Finale Watch Party</a>, complete with 60s costume contest, Mad Men trivia, and retro food and drink. 8:00-11:00 p.m. $10 general admission, $20 admission and two hour open bar.</p>',
                            'icon': 'theatre'
                        },
                        'geometry': {
                            'type': 'Point',
                            'coordinates': [-77.003168, 38.894651]
                        }
                    },
                    {
                        'type': 'Feature',
                        'properties': {
                            'description':
                                '<strong>Big Backyard Beach Bash and Wine Fest</strong><p>EatBar (2761 Washington Boulevard Arlington VA) is throwing a <a href="http://tallulaeatbar.ticketleap.com/2012beachblanket/" target="_blank" title="Opens in a new window">Big Backyard Beach Bash and Wine Fest</a> on Saturday, serving up conch fritters, fish tacos and crab sliders, and Red Apron hot dogs. 12:00-3:00 p.m. $25.grill hot dogs.</p>',
                            'icon': 'bar'
                        },
                        'geometry': {
                            'type': 'Point',
                            'coordinates': [-77.090372, 38.881189]
                        }
                    },
                    {
                        'type': 'Feature',
                        'properties': {
                            'description':
                                '<strong>Ballston Arts & Crafts Market</strong><p>The <a href="https://ballstonarts-craftsmarket.blogspot.com/" target="_blank" title="Opens in a new window">Ballston Arts & Crafts Market</a> sets up shop next to the Ballston metro this Saturday for the first of five dates this summer. Nearly 35 artists and crafters will be on hand selling their wares. 10:00-4:00 p.m.</p>',
                            'icon': 'art-gallery'
                        },
                        'geometry': {
                            'type': 'Point',
                            'coordinates': [-77.111561, 38.882342]
                        }
                    },
                    {
                        'type': 'Feature',
                        'properties': {
                            'description':
                                '<strong>Seersucker Bike Ride and Social</strong><p>Feeling dandy? Get fancy, grab your bike, and take part in this year\'s <a href="http://dandiesandquaintrelles.com/2012/04/the-seersucker-social-is-set-for-june-9th-save-the-date-and-start-planning-your-look/" target="_blank" title="Opens in a new window">Seersucker Social</a> bike ride from Dandies and Quaintrelles. After the ride enjoy a lawn party at Hillwood with jazz, cocktails, paper hat-making, and more. 11:00-7:00 p.m.</p>',
                            'icon': 'bicycle'
                        },
                        'geometry': {
                            'type': 'Point',
                            'coordinates': [-77.052477, 38.943951]
                        }
                    },
                    {
                        'type': 'Feature',
                        'properties': {
                            'description':
                                '<strong>Capital Pride Parade</strong><p>The annual <a href="https://www.capitalpride.org/parade" target="_blank" title="Opens in a new window">Capital Pride Parade</a> makes its way through Dupont this Saturday. 4:30 p.m. Free.</p>',
                            'icon': 'rocket'
                        },
                        'geometry': {
                            'type': 'Point',
                            'coordinates': [-77.043444, 38.909664]
                        }
                    },
                    {
                        'type': 'Feature',
                        'properties': {
                            'description':
                                '<strong>Muhsinah</strong><p>Jazz-influenced hip hop artist <a href="https://www.muhsinah.com" target="_blank" title="Opens in a new window">Muhsinah</a> plays the <a href="https://www.blackcatdc.com">Black Cat</a> (1811 14th Street NW) tonight with <a href="https://www.exitclov.com" target="_blank" title="Opens in a new window">Exit Clov</a> and <a href="https://godsilla.bandcamp.com" target="_blank" title="Opens in a new window">Gods’illa</a>. 9:00 p.m. $12.</p>',
                            'icon': 'music'
                        },
                        'geometry': {
                            'type': 'Point',
                            'coordinates': [-77.031706, 38.914581]
                        }
                    },
                    {
                        'type': 'Feature',
                        'properties': {
                            'description':
                                '<strong>A Little Night Music</strong><p>The Arlington Players\' production of Stephen Sondheim\'s  <a href="http://www.thearlingtonplayers.org/drupal-6.20/node/4661/show" target="_blank" title="Opens in a new window"><em>A Little Night Music</em></a> comes to the Kogod Cradle at The Mead Center for American Theater (1101 6th Street SW) this weekend and next. 8:00 p.m.</p>',
                            'icon': 'music'
                        },
                        'geometry': {
                            'type': 'Point',
                            'coordinates': [-77.020945, 38.878241]
                        }
                    },
                    {
                        'type': 'Feature',
                        'properties': {
                            'description':
                                '<strong>Truckeroo</strong><p><a href="http://www.truckeroodc.com/www/" target="_blank">Truckeroo</a> brings dozens of food trucks, live music, and games to half and M Street SE (across from Navy Yard Metro Station) today from 11:00 a.m. to 11:00 p.m.</p>',
                            'icon': 'music'
                        },
                        'geometry': {
                            'type': 'Point',
                            'coordinates': [-77.007481, 38.876516]
                        }
                    }
                ]
            }
        });
        // Add a layer showing the places.
        map.addLayer({
            'id': 'places',
            'type': 'symbol',
            'source': 'places',
            'layout': {
                'icon-image': '{icon}_15',
                'icon-overlap': 'always'
            }
        });

        // When a click event occurs on a feature in the places layer, open a popup at the
        // location of the feature, with description HTML from its properties.
        map.on('click', 'places', (e) => {
            const coordinates = e.features[0].geometry.coordinates.slice();
            const description = e.features[0].properties.description;

            // Ensure that if the map is zoomed out such that multiple
            // copies of the feature are visible, the popup appears
            // over the copy being pointed to.
            while (Math.abs(e.lngLat.lng - coordinates[0]) > 180) {
                coordinates[0] += e.lngLat.lng > coordinates[0] ? 360 : -360;
            }

            new maplibregl.Popup()
                .setLngLat(coordinates)
                .setHTML(description)
                .addTo(map);
        });

        // Change the cursor to a pointer when the mouse is over the places layer.
        map.on('mouseenter', 'places', () => {
            map.getCanvas().style.cursor = 'pointer';
        });

        // Change it back to a pointer when it leaves.
        map.on('mouseleave', 'places', () => {
            map.getCanvas().style.cursor = '';
        });
    });
</script>
</body>
</html>
```

// FILE ./zoomto-linestring.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Fit to the bounds of a LineString</title>
    <meta property="og:description" content="Get the bounds of a LineString." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<style>
    .btn-control {
        font: bold 12px/20px 'Helvetica Neue', Arial, Helvetica, sans-serif;
        background-color: #3386c0;
        color: #fff;
        position: absolute;
        top: 20px;
        left: 50%;
        z-index: 1;
        border: none;
        width: 200px;
        margin-left: -100px;
        display: block;
        cursor: pointer;
        padding: 10px 20px;
        border-radius: 3px;
    }

    .btn-control:hover {
        background-color: #4ea0da;
    }
</style>
<div id="map"></div>
<button id="zoomto" class="btn-control">Zoom to bounds</button>

<script>
    // A GeoJSON object with a LineString route from the White House to Capitol Hill
    const geojson = {
        'type': 'FeatureCollection',
        'features': [
            {
                'type': 'Feature',
                'geometry': {
                    'type': 'LineString',
                    'properties': {},
                    'coordinates': [
                        [-77.0366048812866, 38.89873175227713],
                        [-77.03364372253417, 38.89876515143842],
                        [-77.03364372253417, 38.89549195896866],
                        [-77.02982425689697, 38.89549195896866],
                        [-77.02400922775269, 38.89387200688839],
                        [-77.01519012451172, 38.891416957534204],
                        [-77.01521158218382, 38.892068305429156],
                        [-77.00813055038452, 38.892051604275686],
                        [-77.00832366943358, 38.89143365883688],
                        [-77.00818419456482, 38.89082405874451],
                        [-77.00815200805664, 38.88989712255097]
                    ]
                }
            }
        ]
    };

    const map = new maplibregl.Map({
        container: 'map',
        style:
            'https://api.maptiler.com/maps/streets/style.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL',
        center: [-77.0214, 38.897],
        zoom: 12
    });

    map.on('load', () => {
        map.addSource('LineString', {
            'type': 'geojson',
            'data': geojson
        });
        map.addLayer({
            'id': 'LineString',
            'type': 'line',
            'source': 'LineString',
            'layout': {
                'line-join': 'round',
                'line-cap': 'round'
            },
            'paint': {
                'line-color': '#BF93E4',
                'line-width': 5
            }
        });

        document
            .getElementById('zoomto')
            .addEventListener('click', () => {
                // Geographic coordinates of the LineString
                const coordinates = geojson.features[0].geometry.coordinates;

                // Pass the first coordinates in the LineString to `lngLatBounds` &
                // wrap each coordinate pair in `extend` to include them in the bounds
                // result. A variation of this technique could be applied to zooming
                // to the bounds of multiple Points or Polygon geometries - it just
                // requires wrapping all the coordinates with the extend method.
                const bounds = coordinates.reduce((bounds, coord) => {
                    return bounds.extend(coord);
                }, new maplibregl.LngLatBounds(coordinates[0], coordinates[0]));

                map.fitBounds(bounds, {
                    padding: 20
                });
            });
    });
</script>
</body>
</html>
```

// FILE ./lod-control.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Level of Detail Control</title>
    <meta property="og:description" content="Modify how Level of Detail behaves at high pitch angles." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
        .listing-group {
            font-family: 'Helvetica Neue', Arial, Helvetica, sans-serif;
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: #fff;
            background-color: gray;
            padding: 10px;
            border-radius: 4px;
        }
    </style>
</head>
<body>
<div id="map"></div>
<table id="listing-group" class="listing-group">
    <tr><td><label for="max-zoom-levels-slider">Max Zoom Levels On Screen</label></td><td><input type="range" id="max-zoom-levels-slider" min="1" max="11" step="1.0" value="9.0" /></td><td><span id="max-zoom-levels-value">9.0</span></td></tr>
    <tr><td><label for="tile-count-ratio-slider">Tile Count Max/Min Ratio</label></td><td><input type="range" id="tile-count-ratio-slider" min="1" max="10" step="0.1" value="3.0" /></td><td><span id="tile-count-ratio-value">3.0</span></td></tr>
</table>
<script>
    function setLodParamsFromUi() {
        map.setSourceTileLodParams(document.getElementById('max-zoom-levels-slider').value, document.getElementById('tile-count-ratio-slider').value);
        document.getElementById('max-zoom-levels-value').textContent = document.getElementById('max-zoom-levels-slider').value;
        document.getElementById('tile-count-ratio-value').textContent = document.getElementById('tile-count-ratio-slider').value;
    }
    const map = (window.map = new maplibregl.Map({
        container: 'map',
        zoom: 12,
        center: [0,0],
        pitch: 77,
        hash: true,
        style: {
            version: 8,
            sources: {
                numbers: {
                    type: 'raster',
                    url: 'https://demotiles.maplibre.org/debug-tiles/number/tiles.json',
                    tileSize: 256,
                    maxzoom: 19
                }
            },
            layers: [
                {
                    id: 'numbers',
                    type: 'raster',
                    source: 'numbers'
                }
            ]
        },
        maxZoom: 22,
        maxPitch: 85
    }));
    map.on('load', () => {
        document.getElementById('max-zoom-levels-slider').addEventListener('change', setLodParamsFromUi);
        document.getElementById('tile-count-ratio-slider').addEventListener('change', setLodParamsFromUi);
        setLodParamsFromUi();
    });

</script>
</body>
</html>
```

// FILE ./globe-fill-extrusion.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Display a globe with a fill extrusion layer</title>
    <meta property="og:description" content="Display a globe with a fill extrusion layer." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<div id="map"></div>
<script>
    const map = new maplibregl.Map({
        container: 'map',
        style: 'https://api.maptiler.com/maps/basic/style.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL',
        center: [30.0, 40.0],
    });

    map.addControl(new maplibregl.GlobeControl(), 'top-right');

    map.on('style.load', () => {
        map.setProjection({
            type: 'globe', // Set projection to globe
        });
    });

    map.on('load', () => {
        map.addSource('extrude-polygons', {
            'type': 'geojson',
            'data': {
                'type': 'FeatureCollection',
                'features': [
                    {
                        'type': 'Feature',
                        'geometry': {
                            'type': 'Polygon',
                            'coordinates': [
                                [
                                    [-120.0, 10.0],
                                    [120.0, 10.0],
                                    [120.0, -10.0],
                                    [-120.0, -10.0]
                                ]
                            ]
                        },
                        'properties': {
                            'height': 150000,
                            'color': '#ff0044'
                        }
                    },
                    {
                        'type': 'Feature',
                        'geometry': {
                            'type': 'Polygon',
                            'coordinates': [
                                [
                                    [10.0, 50.0],
                                    [20.0, 50.0],
                                    [20.0, 40.0],
                                    [10.0, 40.0]
                                ]
                            ]
                        },
                        'properties': {
                            'height': 450000,
                            'color': '#22ff44'
                        }
                    },
                    {
                        'type': 'Feature',
                        'geometry': {
                            'type': 'Polygon',
                            'coordinates': [
                                [
                                    [-70.0, 55.0],
                                    [-65.0, 55.0],
                                    [-65.0, 50.0],
                                    [-70.0, 50.0]
                                ]
                            ]
                        },
                        'properties': {
                            'height': 600000,
                            'color': '#4400ff'
                        }
                    }
                ]
            }
        });
        map.addLayer({
            'id': 'extrude-polygon-layer',
            'source': 'extrude-polygons',
            'type': 'fill-extrusion',
            'paint': {
                'fill-extrusion-color': ['get', 'color'],
                'fill-extrusion-opacity': 1,
                'fill-extrusion-height': ['get', 'height'],
            }
        }, 'waterway');
    });
</script>
</body>
</html>
```

// FILE ./local-ideographs.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Use locally generated ideographs</title>
    <meta property="og:description" content="Set localIdeographFontFamily to override the font used for displaying CJK (Chinese, Japanese and Korean) characters, ignoring the map style. This setting must be a CSS font rule specifying fallbacks of on-device fonts. Set localIdeographFontFamily to false to use server-provided fonts, which is much slower." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<div id="map"></div>

<script>
    const map = new maplibregl.Map({
        container: 'map',
        style:
            'https://api.maptiler.com/maps/streets/style.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL',
        center: [120.3049, 31.4751],
        zoom: 12,
        localIdeographFontFamily: '"Apple LiSung", serif'
    });
</script>
</body>
</html>
```

// FILE ./polygon-popup-on-click.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Show polygon information on click</title>
    <meta property="og:description" content="When a user clicks a polygon, show a popup containing more information." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<style>
    .maplibregl-popup {
        max-width: 400px;
        font: 12px/20px 'Helvetica Neue', Arial, Helvetica, sans-serif;
    }
</style>
<div id="map"></div>
<script>
    const map = new maplibregl.Map({
        container: 'map',
        style: 'https://api.maptiler.com/maps/streets/style.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL',
        center: [-100.04, 38.907],
        zoom: 3
    });

    map.on('load', () => {
        // Add a source for the state polygons.
        map.addSource('states', {
            'type': 'geojson',
            'data': 'https://d2ad6b4ur7yvpq.cloudfront.net/naturalearth-3.3.0/ne_110m_admin_1_states_provinces_shp.geojson'
        });

        // Add a layer showing the state polygons.
        map.addLayer({
            'id': 'states-layer',
            'type': 'fill',
            'source': 'states',
            'paint': {
                'fill-color': 'rgba(200, 100, 240, 0.4)',
                'fill-outline-color': 'rgba(200, 100, 240, 1)'
            }
        });

        // When a click event occurs on a feature in the states layer, open a popup at the
        // location of the click, with description HTML from its properties.
        map.on('click', 'states-layer', (e) => {
            new maplibregl.Popup()
                .setLngLat(e.lngLat)
                .setHTML(e.features[0].properties.name)
                .addTo(map);
        });

        // Change the cursor to a pointer when the mouse is over the states layer.
        map.on('mouseenter', 'states-layer', () => {
            map.getCanvas().style.cursor = 'pointer';
        });

        // Change it back to a pointer when it leaves.
        map.on('mouseleave', 'states-layer', () => {
            map.getCanvas().style.cursor = '';
        });
    });
</script>
</body>
</html>
```

// FILE ./render-world-copies.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Render world copies</title>
    <meta property="og:description" content="Toggle between rendering a single world and multiple copies of the world using setRenderWorldCopies." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<style>
    #menu {
        position: absolute;
        top: 0;
        left: 0;
        background: #fff;
        padding: 10px;
        font-family: 'Open Sans', sans-serif;
    }
</style>

<div id="map"></div>
<div id="menu">
    <div>Set <code>renderWorldCopies</code> to:</div>
    <div>
        <input type="radio" id="true" name="rtoggle" value="true" checked />
        <label for="true">true</label>
    </div>
    <div>
        <input type="radio" id="false" name="rtoggle" value="false" />
        <label for="false">false</label>
    </div>
</div>

<script>
    const map = new maplibregl.Map({
        container: 'map', // container id
        style:
            'https://api.maptiler.com/maps/streets/style.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL', // stylesheet location
        center: [179, 0], // starting position [lng, lat]
        zoom: 0.01 // starting zoom
    });

    const renderOptions = document.getElementById('menu');
    const inputs = renderOptions.getElementsByTagName('input');

    function switchRenderOption(option) {
        const status = option.target.id;
        map.setRenderWorldCopies(status === 'true');
        map.panTo(map.getCenter());
    }

    for (let i = 0; i < inputs.length; i++) {
        inputs[i].onclick = switchRenderOption;
    }
</script>
</body>
</html>
```

// FILE ./add-image.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Add an icon to the map</title>
    <meta property="og:description" content="Add an icon to the map from an external URL and use it in a symbol layer." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<div id="map"></div>

<script>
    const map = new maplibregl.Map({
        container: 'map',
        style:
            'https://api.maptiler.com/maps/streets/style.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL'
    });

    map.on('load', async () => {
        image = await map.loadImage('https://upload.wikimedia.org/wikipedia/commons/7/7c/201408_cat.png');
        map.addImage('cat', image.data);
        map.addSource('point', {
            'type': 'geojson',
            'data': {
                'type': 'FeatureCollection',
                'features': [
                    {
                        'type': 'Feature',
                        'geometry': {
                            'type': 'Point',
                            'coordinates': [0, 0]
                        }
                    }
                ]
            }
        });
        map.addLayer({
            'id': 'points',
            'type': 'symbol',
            'source': 'point',
            'layout': {
                'icon-image': 'cat',
                'icon-size': 0.25
            }
        });
    });
</script>
</body>
</html>
```

// FILE ./geojson-polygon.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Add a GeoJSON polygon</title>
    <meta property="og:description" content="Style a polygon with the fill layer type." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<div id="map"></div>
<script>
    const map = new maplibregl.Map({
        container: 'map',
        style:
            'https://api.maptiler.com/maps/streets/style.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL',
        center: [-68.13734351262877, 45.137451890638886],
        zoom: 5
    });

    map.on('load', () => {
        map.addSource('maine', {
            'type': 'geojson',
            'data': {
                'type': 'Feature',
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': [
                        [
                            [-67.13734351262877, 45.137451890638886],
                            [-66.96466, 44.8097],
                            [-68.03252, 44.3252],
                            [-69.06, 43.98],
                            [-70.11617, 43.68405],
                            [-70.64573401557249, 43.090083319667144],
                            [-70.75102474636725, 43.08003225358635],
                            [-70.79761105007827, 43.21973948828747],
                            [-70.98176001655037, 43.36789581966826],
                            [-70.94416541205806, 43.46633942318431],
                            [-71.08482, 45.3052400000002],
                            [-70.6600225491012, 45.46022288673396],
                            [-70.30495378282376, 45.914794623389355],
                            [-70.00014034695016, 46.69317088478567],
                            [-69.23708614772835, 47.44777598732787],
                            [-68.90478084987546, 47.184794623394396],
                            [-68.23430497910454, 47.35462921812177],
                            [-67.79035274928509, 47.066248887716995],
                            [-67.79141211614706, 45.702585354182816],
                            [-67.13734351262877, 45.137451890638886]
                        ]
                    ]
                }
            }
        });
        map.addLayer({
            'id': 'maine',
            'type': 'fill',
            'source': 'maine',
            'layout': {},
            'paint': {
                'fill-color': '#088',
                'fill-opacity': 0.8
            }
        });
    });
</script>
</body>
</html>
```

// FILE ./add-cog.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Add a COG raster source</title>
    <meta property="og:description" content="Add an external Cloud Optimized Geotiff (COG) as source." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="../../dist/maplibre-gl.css" />
    <script src="../../dist/maplibre-gl-dev.js"></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<div id="map"></div>
<script src="https://unpkg.com/@geomatico/maplibre-cog-protocol@0.4.0/dist/index.js"></script>
<script>
    maplibregl.addProtocol('cog', MaplibreCOGProtocol.cogProtocol);

    const map = new maplibregl.Map({
        container: 'map',
        style: 'https://demotiles.maplibre.org/styles/osm-bright-gl-style/style.json',
        center: [11.39831, 47.26244],
        zoom: 14
    });

    map.on('load', () => {
        map.addSource('cogSource', {
            type: 'raster',
            url: 'cog://https://maplibre.org/maplibre-gl-js/docs/assets/cog.tif',
            tileSize: 256
        });

        map.addLayer({
            id: 'cogLayer',
            source: 'cogSource',
            type: 'raster'
        });
    });
</script>
</body>
</html>
```

// FILE ./globe-vector-tiles.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Display a globe with a vector map</title>
    <meta property="og:description" content="Display a globe with a vector map." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<div id="map"></div>
<script>
    const map = new maplibregl.Map({
        container: 'map',
        style: 'https://api.maptiler.com/maps/streets/style.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL',
        zoom: 0,
        center: [137.9150899566626, 36.25956997955441],
    });

    map.on('style.load', () => {
        map.setProjection({
            type: 'globe', // Set projection to globe
        });
    });
</script>
</body>
</html>
```

// FILE ./canvas-source.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Add a canvas source</title>
    <meta property="og:description" content="Add a canvas source to the map." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<canvas id="canvasID" width="400" height="400">Canvas not supported</canvas>
<div id="map"></div>
<script>
    //Animation from https://javascript.tutorials24x7.com/blog/how-to-draw-animated-circles-in-html5-canvas
    const canvas = document.getElementById('canvasID');
    const ctx = canvas.getContext('2d');
    canvas.style.display = 'none';
    const circles = [];
    const radius = 20;

    function Circle(x, y, dx, dy, radius, color) {
        this.x = x;
        this.y = y;
        this.dx = dx;
        this.dy = dy;

        this.radius = radius;

        this.draw = function () {
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2, false);
            ctx.strokeStyle = color;
            ctx.stroke();
        };

        this.update = function () {
            if (this.x + this.radius > 400 || this.x - this.radius < 0) {
                this.dx = -this.dx;
            }

            if (this.y + this.radius > 400 || this.y - this.radius < 0) {
                this.dy = -this.dy;
            }

            this.x += this.dx;
            this.y += this.dy;

            this.draw();
        };
    }

    for (let i = 0; i < 5; i++) {
        const color = `#${(0x1000000 + Math.random() * 0xffffff).toString(16).substr(1, 6)}`;
        const x = Math.random() * (400 - radius * 2) + radius;
        const y = Math.random() * (400 - radius * 2) + radius;

        const dx = (Math.random() - 0.5) * 2;
        const dy = (Math.random() - 0.5) * 2;

        circles.push(new Circle(x, y, dx, dy, radius, color));
    }

    function animate() {
        requestAnimationFrame(animate);
        ctx.clearRect(0, 0, 400, 400);

        for (let r = 0; r < 5; r++) {
            circles[r].update();
        }
    }

    animate();

    const map = new maplibregl.Map({
        container: 'map',
        zoom: 5,
        minZoom: 4,
        center: [95.899147, 18.088694],
        style:
            'https://api.maptiler.com/maps/streets/style.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL'
    });

    map.on('load', () => {
        map.addSource('canvas-source', {
            type: 'canvas',
            canvas: 'canvasID',
            coordinates: [
                [91.4461, 21.5006],
                [100.3541, 21.5006],
                [100.3541, 13.9706],
                [91.4461, 13.9706]
            ],
            // Set to true if the canvas source is animated. If the canvas is static, animate should be set to false to improve performance.
            animate: true
        });

        map.addLayer({
            id: 'canvas-layer',
            type: 'raster',
            source: 'canvas-source'
        });
    });
</script>
</body>
</html>
```

// FILE ./custom-style-layer.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Add a custom style layer</title>
    <meta property="og:description" content="Use a custom style layer to render custom WebGL content." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<div id="map"></div>
<script>
    const map = new maplibregl.Map({
        container: 'map',
        zoom: 3,
        center: [7.5, 58],
        style: 'https://demotiles.maplibre.org/style.json',
        canvasContextAttributes: {antialias: true} // create the gl context with MSAA antialiasing, so custom layers are antialiased
    });

    // create a custom style layer to implement the WebGL content
    const highlightLayer = {
        id: 'highlight',
        type: 'custom',

        // method called when the layer is added to the map
        // Search for StyleImageInterface in https://maplibre.org/maplibre-gl-js/docs/API/
        onAdd (map, gl) {
        // create GLSL source for vertex shader
            const vertexSource = `#version 300 es
            
            uniform mat4 u_matrix;
            in vec2 a_pos;
            void main() {
                gl_Position = u_matrix * vec4(a_pos, 0.0, 1.0);
            }`;

            // create GLSL source for fragment shader
            const fragmentSource = `#version 300 es

            out highp vec4 fragColor;
            void main() {
                fragColor = vec4(1.0, 0.0, 0.0, 0.5);
            }`;

            // create a vertex shader
            const vertexShader = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(vertexShader, vertexSource);
            gl.compileShader(vertexShader);

            // create a fragment shader
            const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(fragmentShader, fragmentSource);
            gl.compileShader(fragmentShader);

            // link the two shaders into a WebGL program
            this.program = gl.createProgram();
            gl.attachShader(this.program, vertexShader);
            gl.attachShader(this.program, fragmentShader);
            gl.linkProgram(this.program);

            this.aPos = gl.getAttribLocation(this.program, 'a_pos');

            // define vertices of the triangle to be rendered in the custom style layer
            const helsinki = maplibregl.MercatorCoordinate.fromLngLat({
                lng: 25.004,
                lat: 60.239
            });
            const berlin = maplibregl.MercatorCoordinate.fromLngLat({
                lng: 13.403,
                lat: 52.562
            });
            const kyiv = maplibregl.MercatorCoordinate.fromLngLat({
                lng: 30.498,
                lat: 50.541
            });

            // create and initialize a WebGLBuffer to store vertex and color data
            this.buffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
            gl.bufferData(
                gl.ARRAY_BUFFER,
                new Float32Array([
                    helsinki.x,
                    helsinki.y,
                    berlin.x,
                    berlin.y,
                    kyiv.x,
                    kyiv.y
                ]),
                gl.STATIC_DRAW
            );
        },

        // method fired on each animation frame
        render (gl, args) {
            gl.useProgram(this.program);
            gl.uniformMatrix4fv(
                gl.getUniformLocation(this.program, 'u_matrix'),
                false,
                args.defaultProjectionData.mainMatrix
            );
            gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
            gl.enableVertexAttribArray(this.aPos);
            gl.vertexAttribPointer(this.aPos, 2, gl.FLOAT, false, 0, 0);
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 3);
        }
    };

    // add the custom style layer to the map
    map.on('load', () => {
        map.addLayer(highlightLayer, 'crimea-fill');
    });
</script>
</body>
</html>
```

// FILE ./geojson-line.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Add a GeoJSON line</title>
    <meta property="og:description" content="Add a GeoJSON line to a map using addSource, then style it using addLayer’s paint properties." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<div id="map"></div>
<script>
    const map = new maplibregl.Map({
        container: 'map',
        style:
            'https://api.maptiler.com/maps/streets/style.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL',
        center: [-122.486052, 37.830348],
        zoom: 15
    });

    map.on('load', () => {
        map.addSource('route', {
            'type': 'geojson',
            'data': {
                'type': 'Feature',
                'properties': {},
                'geometry': {
                    'type': 'LineString',
                    'coordinates': [
                        [-122.48369693756104, 37.83381888486939],
                        [-122.48348236083984, 37.83317489144141],
                        [-122.48339653015138, 37.83270036637107],
                        [-122.48356819152832, 37.832056363179625],
                        [-122.48404026031496, 37.83114119107971],
                        [-122.48404026031496, 37.83049717427869],
                        [-122.48348236083984, 37.829920943955045],
                        [-122.48356819152832, 37.82954808664175],
                        [-122.48507022857666, 37.82944639795659],
                        [-122.48610019683838, 37.82880236636284],
                        [-122.48695850372314, 37.82931081282506],
                        [-122.48700141906738, 37.83080223556934],
                        [-122.48751640319824, 37.83168351665737],
                        [-122.48803138732912, 37.832158048267786],
                        [-122.48888969421387, 37.83297152392784],
                        [-122.48987674713133, 37.83263257682617],
                        [-122.49043464660643, 37.832937629287755],
                        [-122.49125003814696, 37.832429207817725],
                        [-122.49163627624512, 37.832564787218985],
                        [-122.49223709106445, 37.83337825839438],
                        [-122.49378204345702, 37.83368330777276]
                    ]
                }
            }
        });
        map.addLayer({
            'id': 'route',
            'type': 'line',
            'source': 'route',
            'layout': {
                'line-join': 'round',
                'line-cap': 'round'
            },
            'paint': {
                'line-color': '#888',
                'line-width': 8
            }
        });
    });
</script>
</body>
</html>
```

// FILE ./change-case-of-labels.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Change the case of labels</title>
    <meta property="og:description" content="Use the upcase and downcase expressions to change the case of labels." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<div id="map"></div>
<script>
    const map = new maplibregl.Map({
        container: 'map', // container id
        style:
            'https://api.maptiler.com/maps/streets/style.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL', // stylesheet location
        center: [-116.231, 43.604], // starting position [lng, lat]
        zoom: 11 // starting zoom
    });

    map.on('load', () => {
        // data from https://opendata.cityofboise.org/
        map.addSource('off-leash-areas', {
            'type': 'geojson',
            'data':
                'https://maplibre.org/maplibre-gl-js/docs/assets/boise.geojson'
        });
        map.addLayer({
            'id': 'off-leash-areas',
            'type': 'symbol',
            'source': 'off-leash-areas',
            'layout': {
                'icon-image': 'dog_park',
                'text-field': [
                    'format',
                    ['upcase', ['get', 'FacilityName']],
                    {'font-scale': 0.8},
                    '
',
                    {},
                    ['downcase', ['get', 'Comments']],
                    {'font-scale': 0.6}
                ],
                'text-font': ['Open Sans Semibold', 'Arial Unicode MS Bold'],
                'text-offset': [0, 0.6],
                'text-anchor': 'top'
            }
        });
    });
</script>
</body>
</html>
```

// FILE ./multiple-geometries.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Add multiple geometries from one GeoJSON source</title>
    <meta property="og:description" content="Add a polygon and circle layer from the same GeoJSON source." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<div id="map"></div>
<script>
    const map = new maplibregl.Map({
        container: 'map',
        style:
            'https://api.maptiler.com/maps/streets/style.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL',
        center: [-121.403732, 40.492392],
        zoom: 10
    });

    map.on('load', () => {
        map.addSource('national-park', {
            'type': 'geojson',
            'data': {
                'type': 'FeatureCollection',
                'features': [
                    {
                        'type': 'Feature',
                        'geometry': {
                            'type': 'Polygon',
                            'coordinates': [
                                [
                                    [-121.353637, 40.584978],
                                    [-121.284551, 40.584758],
                                    [-121.275349, 40.541646],
                                    [-121.246768, 40.541017],
                                    [-121.251343, 40.423383],
                                    [-121.32687, 40.423768],
                                    [-121.360619, 40.43479],
                                    [-121.363694, 40.409124],
                                    [-121.439713, 40.409197],
                                    [-121.439711, 40.423791],
                                    [-121.572133, 40.423548],
                                    [-121.577415, 40.550766],
                                    [-121.539486, 40.558107],
                                    [-121.520284, 40.572459],
                                    [-121.487219, 40.550822],
                                    [-121.446951, 40.56319],
                                    [-121.370644, 40.563267],
                                    [-121.353637, 40.584978]
                                ]
                            ]
                        }
                    },
                    {
                        'type': 'Feature',
                        'geometry': {
                            'type': 'Point',
                            'coordinates': [-121.415061, 40.506229]
                        }
                    },
                    {
                        'type': 'Feature',
                        'geometry': {
                            'type': 'Point',
                            'coordinates': [-121.505184, 40.488084]
                        }
                    },
                    {
                        'type': 'Feature',
                        'geometry': {
                            'type': 'Point',
                            'coordinates': [-121.354465, 40.488737]
                        }
                    }
                ]
            }
        });

        map.addLayer({
            'id': 'park-boundary',
            'type': 'fill',
            'source': 'national-park',
            'paint': {
                'fill-color': '#888888',
                'fill-opacity': 0.4
            },
            'filter': ['==', '$type', 'Polygon']
        });

        map.addLayer({
            'id': 'park-volcanoes',
            'type': 'circle',
            'source': 'national-park',
            'paint': {
                'circle-radius': 6,
                'circle-color': '#B42222'
            },
            'filter': ['==', '$type', 'Point']
        });
    });
</script>
</body>
</html>
```

// FILE ./geojson-markers.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Draw GeoJSON points</title>
    <meta property="og:description" content="Draw points from a GeoJSON collection to a map." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<div id="map"></div>
<script>
    const map = new maplibregl.Map({
        container: 'map',
        style:
            'https://api.maptiler.com/maps/positron/style.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL',
        center: [0, 0],
        zoom: 1
    });

    map.on('load', async () => {
        // Add an image to use as a custom marker
        const image = await map.loadImage('https://maplibre.org/maplibre-gl-js/docs/assets/osgeo-logo.png');
        map.addImage('custom-marker', image.data);
        // Add a GeoJSON source with 15 points
        map.addSource('conferences', {
            'type': 'geojson',
            'data': {
                'type': 'FeatureCollection',
                'features': [
                    {
                        'type': 'Feature',
                        'geometry': {
                            'type': 'Point',
                            'coordinates': [100.4933, 13.7551]
                        },
                        'properties': {'year': '2004'}
                    },
                    {
                        'type': 'Feature',
                        'geometry': {
                            'type': 'Point',
                            'coordinates': [6.6523, 46.5535]
                        },
                        'properties': {'year': '2006'}
                    },
                    {
                        'type': 'Feature',
                        'geometry': {
                            'type': 'Point',
                            'coordinates': [-123.3596, 48.4268]
                        },
                        'properties': {'year': '2007'}
                    },
                    {
                        'type': 'Feature',
                        'geometry': {
                            'type': 'Point',
                            'coordinates': [18.4264, -33.9224]
                        },
                        'properties': {'year': '2008'}
                    },
                    {
                        'type': 'Feature',
                        'geometry': {
                            'type': 'Point',
                            'coordinates': [151.195, -33.8552]
                        },
                        'properties': {'year': '2009'}
                    },
                    {
                        'type': 'Feature',
                        'geometry': {
                            'type': 'Point',
                            'coordinates': [2.1404, 41.3925]
                        },
                        'properties': {'year': '2010'}
                    },
                    {
                        'type': 'Feature',
                        'geometry': {
                            'type': 'Point',
                            'coordinates': [-104.8548, 39.7644]
                        },
                        'properties': {'year': '2011'}
                    },
                    {
                        'type': 'Feature',
                        'geometry': {
                            'type': 'Point',
                            'coordinates': [-1.1665, 52.9539]
                        },
                        'properties': {'year': '2013'}
                    },
                    {
                        'type': 'Feature',
                        'geometry': {
                            'type': 'Point',
                            'coordinates': [-122.6544, 45.5428]
                        },
                        'properties': {'year': '2014'}
                    },
                    {
                        'type': 'Feature',
                        'geometry': {
                            'type': 'Point',
                            'coordinates': [126.974, 37.5651]
                        },
                        'properties': {'year': '2015'}
                    },
                    {
                        'type': 'Feature',
                        'geometry': {
                            'type': 'Point',
                            'coordinates': [7.1112, 50.7255]
                        },
                        'properties': {'year': '2016'}
                    },
                    {
                        'type': 'Feature',
                        'geometry': {
                            'type': 'Point',
                            'coordinates': [-71.0314, 42.3539]
                        },
                        'properties': {'year': '2017'}
                    },
                    {
                        'type': 'Feature',
                        'geometry': {
                            'type': 'Point',
                            'coordinates': [39.2794, -6.8173]
                        },
                        'properties': {'year': '2018'}
                    },
                    {
                        'type': 'Feature',
                        'geometry': {
                            'type': 'Point',
                            'coordinates': [26.0961, 44.4379]
                        },
                        'properties': {'year': '2019'}
                    },
                    {
                        'type': 'Feature',
                        'geometry': {
                            'type': 'Point',
                            'coordinates': [-114.0879, 51.0279]
                        },
                        'properties': {'year': '2020'}
                    }
                ]
            }
        });

        // Add a symbol layer
        map.addLayer({
            'id': 'conferences',
            'type': 'symbol',
            'source': 'conferences',
            'layout': {
                'icon-image': 'custom-marker',
                // get the year from the source's "year" property
                'text-field': ['get', 'year'],
                'text-font': [
                    'Open Sans Semibold',
                    'Arial Unicode MS Bold'
                ],
                'text-offset': [0, 1.25],
                'text-anchor': 'top'
            }
        });
    });
</script>
</body>
</html>
```

// FILE ./game-controls.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Navigate the map with game-like controls</title>
    <meta property="og:description" content="Use the keyboard's arrow keys to move around the map with game-like controls." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<div id="map"></div>

<script>
    const map = new maplibregl.Map({
        container: 'map',
        style:
            'https://api.maptiler.com/maps/streets/style.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL',
        center: [-87.6298, 41.8781],
        zoom: 17,
        bearing: -12,
        pitch: 60,
        interactive: false
    });

    // pixels the map pans when the up or down arrow is clicked
    const deltaDistance = 100;

    // degrees the map rotates when the left or right arrow is clicked
    const deltaDegrees = 25;

    function easing(t) {
        return t * (2 - t);
    }

    map.on('load', () => {
        map.getCanvas().focus();

        map.getCanvas().addEventListener(
            'keydown',
            (e) => {
                e.preventDefault();
                if (e.which === 38) {
                    // up
                    map.panBy([0, -deltaDistance], {
                        easing
                    });
                } else if (e.which === 40) {
                    // down
                    map.panBy([0, deltaDistance], {
                        easing
                    });
                } else if (e.which === 37) {
                    // left
                    map.easeTo({
                        bearing: map.getBearing() - deltaDegrees,
                        easing
                    });
                } else if (e.which === 39) {
                    // right
                    map.easeTo({
                        bearing: map.getBearing() + deltaDegrees,
                        easing
                    });
                }
            },
            true
        );
    });
</script>
</body>
</html>
```

// FILE ./animate-camera-around-point.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Animate map camera around a point</title>
    <meta property="og:description" content="Animate the map camera around a point." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<div id="map"></div>
<script>
    const map = new maplibregl.Map({
        container: 'map',
        style:
            'https://api.maptiler.com/maps/streets/style.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL',
        center: [-87.62712, 41.89033],
        zoom: 15.5,
        pitch: 45
    });

    function rotateCamera(timestamp) {
        // clamp the rotation between 0 -360 degrees
        // Divide timestamp by 100 to slow rotation to ~10 degrees / sec
        map.rotateTo((timestamp / 100) % 360, {duration: 0});
        // Request the next frame of the animation.
        requestAnimationFrame(rotateCamera);
    }

    map.on('load', () => {
        // Start the animation.
        rotateCamera(0);

        // Add 3d buildings and remove label layers to enhance the map
        const layers = map.getStyle().layers;
        for (let i = 0; i < layers.length; i++) {
            if (layers[i].type === 'symbol' && layers[i].layout['text-field']) {
                // remove text labels
                map.removeLayer(layers[i].id);
            }
        }

        map.addLayer({
            'id': '3d-buildings',
            'source': 'composite',
            'source-layer': 'building',
            'filter': ['==', 'extrude', 'true'],
            'type': 'fill-extrusion',
            'minzoom': 15,
            'paint': {
                'fill-extrusion-color': '#aaa',

                // use an 'interpolate' expression to add a smooth transition effect to the
                // buildings as the user zooms in
                'fill-extrusion-height': [
                    'interpolate',
                    ['linear'],
                    ['zoom'],
                    15,
                    0,
                    15.05,
                    ['get', 'height']
                ],
                'fill-extrusion-base': [
                    'interpolate',
                    ['linear'],
                    ['zoom'],
                    15,
                    0,
                    15.05,
                    ['get', 'min_height']
                ],
                'fill-extrusion-opacity': 0.6
            }
        });
    });
</script>
</body>
</html>
```

// FILE ./animate-point-along-route.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Animate a point along a route</title>
    <meta property="og:description" content="Use Turf to smoothly animate a point along the distance of a line." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<style>
    .overlay {
        position: absolute;
        top: 10px;
        left: 10px;
    }

    .overlay button {
        font: 600 12px/20px 'Helvetica Neue', Arial, Helvetica, sans-serif;
        background-color: #3386c0;
        color: #fff;
        display: inline-block;
        margin: 0;
        padding: 10px 20px;
        border: none;
        cursor: pointer;
        border-radius: 3px;
    }

    .overlay button:hover {
        background-color: #4ea0da;
    }
</style>
<script
    src="https://www.unpkg.com/turf@2.0.0/turf.min.js"
    charset="utf-8"
></script>

<div id="map"></div>
<div class="overlay">
    <button id="replay">Replay</button>
</div>

<script>
    const map = new maplibregl.Map({
        container: 'map',
        style: 'https://api.maptiler.com/maps/streets/style.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL',
        center: [-96, 37.8],
        zoom: 3
    });

    // San Francisco
    const origin = [-122.414, 37.776];

    // Washington DC
    const destination = [-77.032, 38.913];

    // A simple line from origin to destination.
    const route = {
        'type': 'FeatureCollection',
        'features': [
            {
                'type': 'Feature',
                'geometry': {
                    'type': 'LineString',
                    'coordinates': [origin, destination]
                }
            }
        ]
    };

    // A single point that animates along the route.
    // Coordinates are initially set to origin.
    const point = {
        'type': 'FeatureCollection',
        'features': [
            {
                'type': 'Feature',
                'properties': {},
                'geometry': {
                    'type': 'Point',
                    'coordinates': origin
                }
            }
        ]
    };

    // Calculate the distance in kilometers between route start/end point.
    const lineDistance = turf.lineDistance(route.features[0], 'kilometers');

    const arc = [];

    // Number of steps to use in the arc and animation, more steps means
    // a smoother arc and animation, but too many steps will result in a
    // low frame rate
    const steps = 500;

    // Draw an arc between the `origin` & `destination` of the two points
    for (let i = 0; i < lineDistance; i += lineDistance / steps) {
        const segment = turf.along(route.features[0], i, 'kilometers');
        arc.push(segment.geometry.coordinates);
    }

    // Update the route with calculated arc coordinates
    route.features[0].geometry.coordinates = arc;

    // Used to increment the value of the point measurement against the route.
    let counter = 0;

    map.on('load', () => {
        // Add a source and layer displaying a point which will be animated in a circle.
        map.addSource('route', {
            'type': 'geojson',
            'data': route
        });

        map.addSource('point', {
            'type': 'geojson',
            'data': point
        });

        map.addLayer({
            'id': 'route',
            'source': 'route',
            'type': 'line',
            'paint': {
                'line-width': 2,
                'line-color': '#007cbf'
            }
        });

        map.addLayer({
            'id': 'point',
            'source': 'point',
            'type': 'symbol',
            'layout': {
                'icon-image': 'airport_15',
                'icon-rotate': ['get', 'bearing'],
                'icon-rotation-alignment': 'map',
                'icon-overlap': 'always',
                'icon-ignore-placement': true
            }
        });

        function animate() {
            // Update point geometry to a new position based on counter denoting
            // the index to access the arc.
            point.features[0].geometry.coordinates =
                route.features[0].geometry.coordinates[counter];

            // Calculate the bearing to ensure the icon is rotated to match the route arc
            // The bearing is calculate between the current point and the next point, except
            // at the end of the arc use the previous point and the current point
            point.features[0].properties.bearing = turf.bearing(
                turf.point(
                    route.features[0].geometry.coordinates[
                        counter >= steps ? counter - 1 : counter
                    ]
                ),
                turf.point(
                    route.features[0].geometry.coordinates[
                        counter >= steps ? counter : counter + 1
                    ]
                )
            );

            // Update the source with this new data.
            map.getSource('point').setData(point);

            // Request the next frame of animation so long the end has not been reached.
            if (counter < steps) {
                requestAnimationFrame(animate);
            }

            counter = counter + 1;
        }

        document
            .getElementById('replay')
            .addEventListener('click', () => {
                // Set the coordinates of the original point back to origin
                point.features[0].geometry.coordinates = origin;

                // Update the source layer
                map.getSource('point').setData(point);

                // Reset the counter
                counter = 0;

                // Restart the animation.
                animate(counter);
            });

        // Start the animation.
        animate(counter);
    });
</script>
</body>
</html>
```

// FILE ./local-geojson.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>View local GeoJSON</title>
    <meta property="og:description" content="View local GeoJSON without server upload." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<style>
    #file {
        position: absolute;
        top: 0;
        left: 0;
    }
</style>
<div id="map"></div>
<input
    type="file"
    id="file"
    name="file"
    accept="application/geo+json,application/vnd.geo+json,.geojson"
/>
<script>
    const map = new maplibregl.Map({
        container: 'map',
        style:
            'https://api.maptiler.com/maps/streets/style.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL',
        center: [-8.3226655, 53.7654751],
        zoom: 8
    });

    function handleFileSelect(evt) {
        const file = evt.target.files[0]; // Read first selected file

        const reader = new FileReader();

        reader.onload = function (theFile) {
            // Parse as (geo)JSON
            const geoJSONcontent = JSON.parse(theFile.target.result);

            // Add as source to the map
            map.addSource('uploaded-source', {
                'type': 'geojson',
                'data': geoJSONcontent
            });

            map.addLayer({
                'id': 'uploaded-polygons',
                'type': 'fill',
                'source': 'uploaded-source',
                'paint': {
                    'fill-color': '#888888',
                    'fill-outline-color': 'red',
                    'fill-opacity': 0.4
                },
                // filter for (multi)polygons; for also displaying linestrings
                // or points add more layers with different filters
                'filter': ['==', '$type', 'Polygon']
            });
        };

        // Read the GeoJSON as text
        reader.readAsText(file, 'UTF-8');
    }

    document
        .getElementById('file')
        .addEventListener('change', handleFileSelect, false);
</script>
</body>
</html>
```

// FILE ./filter-markers.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Filter symbols by toggling a list</title>
    <meta property="og:description" content="Filter a set of symbols based on a property value in the data." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<style>
    .filter-group {
        font: 12px/20px 'Helvetica Neue', Arial, Helvetica, sans-serif;
        font-weight: 600;
        position: absolute;
        top: 10px;
        right: 10px;
        z-index: 1;
        border-radius: 3px;
        width: 120px;
        color: #fff;
    }

    .filter-group input[type='checkbox']:first-child + label {
        border-radius: 3px 3px 0 0;
    }

    .filter-group label:last-child {
        border-radius: 0 0 3px 3px;
        border: none;
    }

    .filter-group input[type='checkbox'] {
        display: none;
    }

    .filter-group input[type='checkbox'] + label {
        background-color: #3386c0;
        display: block;
        cursor: pointer;
        padding: 10px;
        border-bottom: 1px solid rgba(0, 0, 0, 0.25);
    }

    .filter-group input[type='checkbox'] + label {
        background-color: #3386c0;
        text-transform: capitalize;
    }

    .filter-group input[type='checkbox'] + label:hover,
    .filter-group input[type='checkbox']:checked + label {
        background-color: #4ea0da;
    }

    .filter-group input[type='checkbox']:checked + label:before {
        content: '✔';
        margin-right: 5px;
    }
</style>
<div id="map"></div>
<nav id="filter-group" class="filter-group"></nav>

<script>
    const places = {
        'type': 'FeatureCollection',
        'features': [
            {
                'type': 'Feature',
                'properties': {
                    'icon': 'theatre'
                },
                'geometry': {
                    'type': 'Point',
                    'coordinates': [-77.038659, 38.931567]
                }
            },
            {
                'type': 'Feature',
                'properties': {
                    'icon': 'theatre'
                },
                'geometry': {
                    'type': 'Point',
                    'coordinates': [-77.003168, 38.894651]
                }
            },
            {
                'type': 'Feature',
                'properties': {
                    'icon': 'bar'
                },
                'geometry': {
                    'type': 'Point',
                    'coordinates': [-77.090372, 38.881189]
                }
            },
            {
                'type': 'Feature',
                'properties': {
                    'icon': 'bicycle'
                },
                'geometry': {
                    'type': 'Point',
                    'coordinates': [-77.052477, 38.943951]
                }
            },
            {
                'type': 'Feature',
                'properties': {
                    'icon': 'music'
                },
                'geometry': {
                    'type': 'Point',
                    'coordinates': [-77.031706, 38.914581]
                }
            },
            {
                'type': 'Feature',
                'properties': {
                    'icon': 'music'
                },
                'geometry': {
                    'type': 'Point',
                    'coordinates': [-77.020945, 38.878241]
                }
            },
            {
                'type': 'Feature',
                'properties': {
                    'icon': 'music'
                },
                'geometry': {
                    'type': 'Point',
                    'coordinates': [-77.007481, 38.876516]
                }
            }
        ]
    };

    const filterGroup = document.getElementById('filter-group');
    const map = new maplibregl.Map({
        container: 'map',
        style:
            'https://api.maptiler.com/maps/streets/style.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL',
        center: [-77.04, 38.907],
        zoom: 11.15
    });

    map.on('load', () => {
        // Add a GeoJSON source containing place coordinates and information.
        map.addSource('places', {
            'type': 'geojson',
            'data': places
        });

        places.features.forEach((feature) => {
            const symbol = feature.properties['icon'];
            const layerID = `poi-${symbol}`;

            // Add a layer for this symbol type if it hasn't been added already.
            if (!map.getLayer(layerID)) {
                map.addLayer({
                    'id': layerID,
                    'type': 'symbol',
                    'source': 'places',
                    'layout': {
                        'icon-image': `${symbol}_15`,
                        'icon-overlap': 'always'
                    },
                    'filter': ['==', 'icon', symbol]
                });

                // Add checkbox and label elements for the layer.
                const input = document.createElement('input');
                input.type = 'checkbox';
                input.id = layerID;
                input.checked = true;
                filterGroup.appendChild(input);

                const label = document.createElement('label');
                label.setAttribute('for', layerID);
                label.textContent = symbol;
                filterGroup.appendChild(label);

                // When the checkbox changes, update the visibility of the layer.
                input.addEventListener('change', (e) => {
                    map.setLayoutProperty(
                        layerID,
                        'visibility',
                        e.target.checked ? 'visible' : 'none'
                    );
                });
            }
        });
    });
</script>
</body>
</html>
```

// FILE ./map-tiles.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Add a raster tile source</title>
    <meta property="og:description" content="Add a third-party raster source to the map." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<div id="map"></div>
<script>
    const map = new maplibregl.Map({
        container: 'map', // container id
        style: {
            'version': 8,
            'sources': {
                'raster-tiles': {
                    'type': 'raster',
                    'tiles': [
                        // NOTE: Layers from Stadia Maps do not require an API key for localhost development or most production
                        // web deployments. See https://docs.stadiamaps.com/authentication/ for details.
                        'https://tiles.stadiamaps.com/tiles/stamen_watercolor/{z}/{x}/{y}.jpg'
                    ],
                    'tileSize': 256,
                    'attribution':
                        'Map tiles by <a target="_blank" href="https://stamen.com">Stamen Design</a>; Hosting by <a href="https://stadiamaps.com/" target="_blank">Stadia Maps</a>. Data &copy; <a href="https://www.openstreetmap.org/about" target="_blank">OpenStreetMap</a> contributors'
                }
            },
            'layers': [
                {
                    'id': 'simple-tiles',
                    'type': 'raster',
                    'source': 'raster-tiles',
                    'minzoom': 0,
                    'maxzoom': 22
                }
            ]
        },
        center: [-74.5, 40], // starting position
        zoom: 2 // starting zoom
    });
</script>
</body>
</html>
```

// FILE ./fallback-image.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Use a fallback image</title>
    <meta property="og:description" content="Use a coalesce expression to display another image when a requested image is not available." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<div id="map"></div>
<script>
    const map = new maplibregl.Map({
        container: 'map',
        style: 'https://api.maptiler.com/maps/streets/style.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL',
        center: [-77, 38.75],
        zoom: 5
    });
    map.on('load', () => {
        map.addSource('points', {
            'type': 'geojson',
            'data': {
                'type': 'FeatureCollection',
                'features': [
                    {
                        'type': 'Feature',
                        'geometry': {
                            'type': 'Point',
                            'coordinates': [
                                -77.03238901390978, 38.913188059745586
                            ]
                        },
                        'properties': {
                            'title': 'Washington DC',
                            'icon': 'monument'
                        }
                    },
                    {
                        'type': 'Feature',
                        'geometry': {
                            'type': 'Point',
                            'coordinates': [-79.9959, 40.4406]
                        },
                        'properties': {
                            'title': 'Pittsburgh',
                            'icon': 'bridges'
                        }
                    },
                    {
                        'type': 'Feature',
                        'geometry': {
                            'type': 'Point',
                            'coordinates': [-76.2859, 36.8508]
                        },
                        'properties': {
                            'title': 'Norfolk',
                            'icon': 'harbor'
                        }
                    }
                ]
            }
        });
        map.addLayer({
            'id': 'points',
            'type': 'symbol',
            'source': 'points',
            'layout': {
                'icon-image': [
                    'coalesce',
                    ['image', ['concat', ['get', 'icon'], '_15']],
                    ['image', 'marker_15']
                ],
                'text-field': ['get', 'title'],
                'text-font': ['Open Sans Semibold', 'Arial Unicode MS Bold'],
                'text-offset': [0, 0.6],
                'text-anchor': 'top'
            }
        });
    });
</script>
</body>
</html>
```

// FILE ./hybrid-terrain.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Display a hybrid satellite map with terrain elevation</title>
    <meta property="og:description" content="Display a hybrid satellite map with terrain elevation." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<div id="map"></div>
<script>
    const map = new maplibregl.Map({
        container: 'map',
        zoom: 12,
        center: [11.39085, 47.27574],
        pitch: 70,
        maxPitch: 95
    });

    map.setStyle('https://api.maptiler.com/maps/hybrid/style.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL', {
            transformStyle: (previousStyle, nextStyle) => {
                nextStyle.projection = {type: 'globe'};
                nextStyle.sources = {
                    ...nextStyle.sources, terrainSource: {
                        type: 'raster-dem',
                        url: 'https://api.maptiler.com/tiles/terrain-rgb-v2/tiles.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL',
                        tileSize: 256
                    },
                    hillshadeSource: {
                        type: 'raster-dem',
                        url: 'https://api.maptiler.com/tiles/terrain-rgb-v2/tiles.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL',
                        tileSize: 256
                    }
                }
                nextStyle.terrain = {
                    source: 'terrainSource',
                    exaggeration: 1
                }

                nextStyle.sky = {
                    'atmosphere-blend': [
                        'interpolate',
                        ['linear'],
                        ['zoom'],
                        0, 1,
                        2, 0
                    ],
                }

                nextStyle.layers.push({
                    id: 'hills',
                    type: 'hillshade',
                    source: 'hillshadeSource',
                    layout: { visibility: 'visible' },
                    paint: { 'hillshade-shadow-color': '#473B24' }
                })

                return nextStyle
            }
        })

    map.addControl(
        new maplibregl.NavigationControl({
            visualizePitch: true,
            showZoom: true,
            showCompass: true
        })
    );


    map.addControl(
        new maplibregl.GlobeControl()
    );

    map.addControl(
        new maplibregl.TerrainControl({
            source: 'terrainSource',
            exaggeration: 1
        })
    );
</script>
</body>
</html>
```

// FILE ./navigation.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Display map navigation controls</title>
    <meta property="og:description" content="Add zoom and rotation controls to the map." />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='../../dist/maplibre-gl.css' />
    <script src='../../dist/maplibre-gl-dev.js'></script>
    <style>
        body { margin: 0; padding: 0; }
        html, body, #map { height: 100%; }
    </style>
</head>
<body>
<div id="map"></div>
<script>
    const map = new maplibregl.Map({
        container: 'map', // container id
        style:
            'https://api.maptiler.com/maps/streets/style.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL',
        center: [-74.5, 40], // starting position
        zoom: 9, // starting zoom
        rollEnabled: true // Enable mouse control of camera roll angle with `Ctrl` + right-click and drag
    });

    // Add zoom and rotation controls to the map.
    map.addControl(new maplibregl.NavigationControl({
        visualizePitch: true,
        visualizeRoll: true,
        showZoom: true,
        showCompass: true
    }));
</script>
</body>
</html>
```
